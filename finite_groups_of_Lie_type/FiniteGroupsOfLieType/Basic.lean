/-TODO

Create BN pair and show that they are BNWphiQuadruplet
- PGLn (F)


-/
import Mathlib.GroupTheory.Perm.Subgroup
import Mathlib.GroupTheory.QuotientGroup
import Mathlib.GroupTheory.Coxeter.Basic
import Mathlib.Tactic.Group
import FiniteGroupsOfLieType.DoubleCosets

open Subgroup
open scoped Pointwise
variable {G : Type*} [Group G] {A : Type*}

/-- A structure simpler to work on than BN pair by avoiding using quotients.-/
structure BNMphiQuadruplet (G : Type*) [Group G] (A : Type*) where
  /-- The Borel Subgroup of the BN-pair.-/
  B : Subgroup G
  /-- The N subgroup of the BN-pair-/
  N : Subgroup G
  /-- The Coxeter matrix of the group B/(B∩N)-/
  M : CoxeterMatrix A
  /--The projection from N to M.Group ≃ B/(B∩N) -/
  phi : N →* M.Group
  /-- G is generated by N and B.-/
  prop1 : ⊤ = B ⊔ N
  /-- Ensure that phi is a projection-/
  prop2 : Function.Surjective phi
  /-- Ensure that M.Group ≃ B/(B ∩ N)-/
  prop3 : phi.ker = B.subgroupOf N
  /-- For all  ni ∈ N that maps to one of the generators of the Coxeter group B/(B∩N), niBni ≠ B-/
  prop4 : ∀ (ni: N) (i : A) , phi ni = M.simple i -> {(ni :G) * (b : G) * ni | b : B} ≠ B
  /-- For all  ni ∈ N that maps to one of the generators of the Coxeter group B/(B∩N) and n∈N,
  niBn ⊆ Bn niB ∪ BnB-/
  prop5 :  ∀ (n ni : N) (i : A), phi ni = M.simple i ->
            {ni * b.val * n | b : B} ⊆  DoubleCoset B (n * ni) ∪ DoubleCoset B n


section Quotient

variable (TS : (BNMphiQuadruplet G A)) {G' : Type*} [Group  G']

open Function
open MonoidHom

/-- Easier way to prove `QuotientBNMphiQuadruplet'` has a `BNMphiQuadruplet` structure.-/
def QuotientBNMphiQuadruplet
  {pi : G →* G'} (pi_surj: Surjective pi) (ker_pi_le_B : pi.ker ≤ TS.B) {pi' : TS.N →* TS.N.map pi}
  (pi'_restpi : ∀ n, pi n.val = (pi' n).val)
  {phi': TS.N.map pi →* TS.M.Group} (pi_comm_phi' : TS.phi = phi'.comp pi') :
    BNMphiQuadruplet G' A where
  B := TS.B.map pi
  N := TS.N.map pi
  M := TS.M
  phi := phi'

  prop1 := by simp [ ← map_sup TS.B TS.N pi, ← TS.prop1,
                ←range_top_of_surjective pi pi_surj,range_eq_map]

  prop2 := fun x ↦
    match TS.prop2 x with
    | ⟨a,h⟩ => ⟨ pi' a, by simp [pi_comm_phi'] at h ; assumption ⟩

  prop3 := by
    have : Surjective pi'  := by
      intro x
      rcases x.2 with ⟨y,yinN,h⟩
      use ⟨y,yinN⟩
      apply subtype_injective
      simp [← h, pi'_restpi ⟨y,yinN⟩]
    ext x
    rcases this x with ⟨a,hₐ⟩
    simp [mem_ker,mem_subgroupOf]
    constructor
    · intro h
      have :a ∈ TS.phi.ker:= by simp [mem_ker,pi_comm_phi',(hₐ.symm) ▸  h]
      rw [TS.prop3, mem_subgroupOf] at this
      use a.val
      simp [this, ← hₐ,pi'_restpi]
    intro ⟨y, yinB, ycoex⟩
    have : phi' (pi' a) = TS.phi a := by simp [pi_comm_phi']
    simp [← hₐ,this, ← mem_ker, TS.prop3, mem_subgroupOf]
    have : pi a.val = x.val := by simp [pi'_restpi, hₐ]
    rw [← this] at ycoex
    have : a.val*y⁻¹ ∈ TS.B :=by
      apply ker_pi_le_B
      simp [mem_ker, ycoex]
    have := TS.B.mul_mem this yinB
    simp at this
    assumption

  prop4 :=by
    intro ni i hi
    rcases ni.2 with ⟨ni',ni'inN,hi'⟩
    have h:= TS.prop4 ⟨ni', ni'inN⟩ i
    contrapose h
    push_neg at h ⊢
    constructor
    · simp [← hi, pi_comm_phi', pi'_restpi, ← hi']
      have : pi' ⟨ni', ni'inN⟩ =  ni :=by
        apply subtype_injective
        simp [← hi', ← pi'_restpi]
      rw [this]
    ext x
    simp
    constructor
    · intro ⟨a,ainB, ha⟩
      have :pi x ∈ {y :G' | ∃ b :TS.B.map pi, (↑ni :G') * ↑b * ↑ni = y} :=by
        simp
        use a
        simp [← ha, hi', ainB]
      rw [h] at this
      rcases this with ⟨y,yinB, hy⟩
      have : x*y⁻¹ ∈ TS.B := by apply ker_pi_le_B  ; simp [mem_ker, hy]
      have  := TS.B.mul_mem this yinB
      simp at this
      assumption
    intro xinB
    have : pi x ∈ (TS.B.map pi) := by use x ; simp [xinB]
    rw [Set.ext_iff] at h
    rcases h (pi x)|>.2 this with ⟨a,h'⟩
    rcases a.2 with ⟨a0,a0inB,ha0⟩
    let D :=ni'⁻¹*x*ni'⁻¹*a0⁻¹
    have : D ∈ ker pi:= by
      simp [mem_ker,D, ← h', hi', ha0]
      group
    use D*a0
    simp at a0inB
    simp [TS.B.mul_mem (ker_pi_le_B this) a0inB]
    simp [D]
    group

  prop5:=by
    intro n ni i hi x ⟨b,hb⟩
    rcases ni.2 with ⟨_ni',_ni'inN,hni⟩
    rcases n.2 with ⟨_n',_n'inN,hn⟩
    let n' : TS.N := ⟨_n', _n'inN⟩
    let ni' : TS.N :=⟨_ni', _ni'inN⟩
    rcases pi_surj x with ⟨x',hx⟩

    have : TS.phi ni' = TS.M.simple i  := by
      have :  (pi' ni') = ni :=by apply subtype_injective ; simp [← pi'_restpi, hni, ni']
      simp [← hi, pi_comm_phi', this]

    have hi' := TS.prop5 n' ni' i this

    have :x' ∈ {y:G | ∃ b :TS.B, ni'.val * ↑b * n'.val = y} :=by
      rcases b.2 with ⟨b',b'inB, hb'⟩
      let D :=_ni'⁻¹ * x' * _n'⁻¹ * b'⁻¹
      have :D  ∈ pi.ker:=by
        simp [mem_ker,D,hx, ← hb , hn, hni,hb' ]
        group
      simp
      use D*b'
      simp [TS.B.mul_mem (ker_pi_le_B this) b'inB]
      simp [D] ; group
    obtain h|h := hi' this
    on_goal 1 => left
    on_goal 2 => right
    all_goals {
      simp [DoubleCoset] at h ⊢
      rcases h with ⟨a1,a1inB,a2,a2inB, ha ⟩
      use a1
      simp [a1inB]
      use a2
      simp [a2inB,← hx,← hn,← hni, ← ha]
    }

variable (G' : Type*) [Group G']
variable (Z : Subgroup G) [Normal Z] (ZleB : Z ≤ TS.B)

lemma kerpi_le_B:(QuotientGroup.mk' Z).ker ≤ TS.B  :=by rw [QuotientGroup.ker_mk']; exact ZleB

/-add to mathlib ?-/
lemma map_of_restrictedrange (x : ((QuotientGroup.mk' Z).restrict TS.N).range) :
    x.val ∈ TS.N.map (QuotientGroup.mk' Z) :=
  match x.2 with | ⟨y,hy⟩=> ⟨y,by simp [← hy]⟩

/-- A group homomorphsim from pi|N (N) to pi(N).-/
def quotientshom:((QuotientGroup.mk' Z).restrict TS.N).range →* TS.N.map (QuotientGroup.mk' Z) where
  toFun := fun x => (⟨x.1, map_of_restrictedrange TS Z x⟩:TS.N.map (QuotientGroup.mk' Z))
  map_one' := by simp
  map_mul' := by simp

/--The canonical projection from TS.N to its image in G/Z.-/
def pi' : TS.N →* TS.N.map (QuotientGroup.mk' Z):=
  (quotientshom TS Z).comp ((QuotientGroup.mk' Z).restrict TS.N).rangeRestrict

lemma pi'_restpi : ∀ n, (QuotientGroup.mk' Z) n.val = (pi' TS Z n).val :=
  fun _ => by simp [pi', quotientshom]

lemma Z_le_ker_phi : (Z.subgroupOf TS.N) ≤ TS.phi.ker:=
  fun _ =>by simp [TS.prop3, mem_subgroupOf] ; apply ZleB

/--Technical definition to buil `prequotientN`.-/
def quotient_surj(x : TS.N.map (QuotientGroup.mk' Z))(y : TS.N) := x=(QuotientGroup.mk' Z) y

lemma quotient_surj' (x : TS.N.map (QuotientGroup.mk' Z)) :
     ∃ y, quotient_surj TS Z x y :=
  match x.2 with | ⟨a,ha,h'⟩ =>  ⟨⟨a,ha⟩, h'.symm⟩

/--The map that maps the preimage of x∈N/Z to one of its preimage in N.-/
noncomputable
def prequotientN (x : TS.N.map (QuotientGroup.mk' Z)) : TS.N:=
  Classical.choose (quotient_surj' TS Z x)

/--The canonical group homomorphism from the N/Z to the image of N in the quotient G/Z.-/
noncomputable
def Nquotient_of_quotientN : (TS.N.map (QuotientGroup.mk' Z)) →* TS.N ⧸ Z.subgroupOf TS.N  where
  toFun := QuotientGroup.mk' (Z.subgroupOf TS.N) ∘  (prequotientN TS Z )
  map_one' := by
    have :=Classical.choose_spec (quotient_surj' TS Z 1)
    simp [mem_subgroupOf]
    simp [quotient_surj] at this
    have : (prequotientN TS Z 1).val ∈ (QuotientGroup.mk' Z).ker := by
      rw [mem_ker, this, prequotientN] ; simp
    simp at this
    assumption

  map_mul' := by
    intro x y
    simp
    have hx := Classical.choose_spec (quotient_surj' TS Z x)
    have hy := Classical.choose_spec (quotient_surj' TS Z y)
    have hxy := Classical.choose_spec (quotient_surj' TS Z (x*y))
    simp [quotient_surj] at hx hy hxy
    suffices h :QuotientGroup.mk' (Z.subgroupOf TS.N) ( (prequotientN TS Z (x * y)) *
                  (prequotientN TS Z y)⁻¹  * (prequotientN TS Z x)⁻¹ )=1 by
      simp at h
      rw [← one_mul ((prequotientN TS Z x) : TS.N ⧸ (Z.subgroupOf TS.N)), ← h]
      simp
    rw [← mem_ker]
    simp [mem_subgroupOf]
    suffices h: QuotientGroup.mk' Z ((prequotientN TS Z (x * y)) * (prequotientN TS Z y)⁻¹  * (prequotientN TS Z x)⁻¹ ) = 1 by
      rw [← mem_ker] at h
      simp at h
      assumption
    simp [prequotientN, ← hx, ← hy, ← hxy]

lemma prequotient_prop (Z : Subgroup G) [Normal Z] (y : TS.N):
    Nquotient_of_quotientN TS Z (pi' TS Z y) = ((QuotientGroup.mk' (Z.subgroupOf TS.N)) y)  :=by
  simp [Nquotient_of_quotientN, QuotientGroup.eq, mem_subgroupOf, prequotientN]
  have this := Classical.choose_spec <| quotient_surj' TS Z <| pi' TS Z y
  simp [quotient_surj,←  pi'_restpi] at this
  symm at this
  rw [QuotientGroup.eq'] at this
  simp [this]

/--The lift of TS.phi to TS.N/Z.-/
noncomputable
def phi' : (TS.N.map (QuotientGroup.mk' Z)) →* TS.M.Group :=
  (QuotientGroup.lift (Z.subgroupOf TS.N) TS.phi (Z_le_ker_phi TS Z ZleB)).comp
    (Nquotient_of_quotientN TS Z)


lemma pi_comm_phi' : TS.phi = (phi' TS Z ZleB).comp (pi' TS Z) :=by
  ext x; simp [phi',prequotient_prop TS Z]

/-- If (B,N,M,phi) is a `BNMphiQuadruplet` over G and Z is a subgroup of `phi.ker` normal in G,
then (B/Z, N/Z, M, phi') is a `BNMphiQuadruplet` over G/Z with phi' being the map phi lifted to N/Z-/
noncomputable
def QuotientBNMphiQuadruplet' : BNMphiQuadruplet (G ⧸ Z) A :=
    QuotientBNMphiQuadruplet TS (QuotientGroup.mk'_surjective Z) (kerpi_le_B TS Z ZleB)
      (pi'_restpi TS Z) (pi_comm_phi' TS Z ZleB)

end Quotient

section DoubleCoset

variable (TS : (BNMphiQuadruplet G A)) {G' : Type*} [Group  G']

/-
def  BWB :Subgroup G where
  carrier := TS.B *  TS.N * TS.B
  one_mem' := sorry
  mul_mem' := sorry
  inv_mem' := sorry

theorem groupDecomp : ⊤ = BWB TS := by
  apply le_antisymm
  · rw [TS.prop1]
    apply sup_le
    · simp [BWB]
      intros
      apply set_mul_le_mem_one
      simp [set_mul]
      use 1; simp ; exact ⟨TS.N.one_mem, TS.B.one_mem⟩
    simp [BWB]
    intro x h
    simp
    apply set_mul_le_one_mem TS.B.one_mem <| set_mul_le_mem_one TS.B.one_mem h
  simp


def f (n : TS.N) : Set G := C TS.B n
lemma yes : ∀ m n : TS.N, QuotientGroup.con (TS.phi.ker) m n → f TS m = f TS n  :=by
  intro m n h
  simp [QuotientGroup.con,QuotientGroup.leftRel_apply]  at h
  simp [f]
  have : m.val = (1 :TS.B).val * n.val * ( n⁻¹*m).val :=by sorry
  apply doubleCoset_quotient TS.B this (1:TS.B) ((m⁻¹ *n)⁻¹) this



def g : TS.N ⧸ TS.phi.ker → Set G := Quotient.lift (f TS) (yes TS)
/-
noncomputable
def  doubleCoset_Coexter_equiv : TS.M.Group ≃ {C TS.B w | w∈ N} where
  toFun :=
-/




-/



end DoubleCoset

#lint
