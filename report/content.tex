\section{The Lean theorem prover}
\label{sec:lean-intro}

This section is an introduction the Lean theorem prover, its aim is to give to the readers unfamiliar with \Lean the minimal amount of knowledge necessary to understand this report. Resources for learning how to use \Lean are available at \url{https://lean-lang.org/documentation/}.
. One can find the code used in this section by clicking \editor\footnote{If the link is not working, the example file can be found \href{https://github.com/corent1234/BNpairs/blob/master/report/example.lean}{here} and pasted in the \href{https://live.lean-lang.org/}{\Lean 4 web editor}.}. We strongly encourage the reader to interact with the code while reading this section for a better understanding of the notions manipulated.

In this section we begin present the notion of type which is of capital importance in \Lean. We then describe ways to construct new types which will be used in this internship. Finally, we briefly present the types \lean{Prop} and \lean{Subgroup}.

\subsection{General introduction to Lean}%
\label{sub:Introduction to type theory}

\Lean is based on the \emph{calculus of construction} a type theory first created by Thierry Coquand and that notably serves as foundation for the \href{https://coq.inria.fr/}{Coq proof assistant}. As such the notion of type is of capital importance in \Lean, and this subsection aims to give the reader basic knowledges about this concept.

\subsubsection{Typing}
  Every \Lean expression, that is every variable, number, string, etc., is associated with a property called a type. This type will has many usage, for example infer which operations can and should be used on the expression. For instance, most programming languages have \lean{Int} (or \lean{int}) and \lean{String} (or \lean{string} or \lean{str}) types to represent integers and strings of characters. While the addition of two integers is perfectly defined as an operation, adding an integer with a string is a bit more mystical. Thus, the compiler or executer of the programming language can become pretty unpleased when asked to add terms of type \lean{Int} and \lean{String}.

  We will denote as \lean{expr : t} the fact that the expression \lean{expr} has type \lean{t}. For instance, \lean{4 : ℕ}, \lean{true : Bool} and \lean{∃ n : ℕ, 3 ≤ n : Prop}. Here, the type \lean{ℕ} represent natural numbers, \lean{Bool} booleans and \lean{Prop} mathematical properties. The last type will be discussed in more details in \ref{sub:somtypes}. One can access, to the type of a term using the \lean{#check} command, see \editor.

  %Types themselves are considered as objects and therefore also have types in \Lean, for instance \lean{Bool : Type} and \lean{Type : Type 2}.

To define an object and even types in \Lean, one can to use the \lean{def} keyword :
\begin{leancode}
def one : ℕ := 1
def vrai : Bool := true

#check one --ℕ

def  α : Type := ℕ
def one' : α := one

#check one' --α
\end{leancode}


On some occasion the \lean{abbrev} keyword will be used instead of \lean{def} to define objects, the reader unfamiliar with \Lean can simply consider it as equivalent to \lean{def}.

It is also possible to evaluate expression in \Lean by using the \lean{#eval} command :
\begin{leancode}
#eval 2 + 3 --5
#eval one --1
#eval one' --1
#eval vrai && true --false
\end{leancode}

\subsubsection{Function type}
We will now discuss some ways to create new types in \Lean, starting with the types of functions. 

If \lean{α} and \lean{β} are two types then the type of function from \lean{α} to \lean{β} is denoted \lean{α → β}. For instance :
\begin{leancode}
#check Bool.not -- Bool → Bool 
#check Nat.add -- ℕ → ℕ → ℕ
\end{leancode}

One way to create functions in \Lean is to use the \lean{fun} keyword. If from a variable \lean{x : α} it is possible to construct a term \lean{t : β} then the expression \lean{fun (x : α) => t : α → β} represent the function mapping \lean{x} to\lean{t}. Here are some examples :
\begin{leancode}
#check fun n : ℕ => n + 2 -- ℕ → ℕ
#check fun (b : Bool) => ¬ b -- Bool → Bool

#check fun (x : ℕ) (b : Bool) => if not b then x else x + 1   -- ℕ → Bool → ℕ
#check fun x b => if not b then x else x + 1   -- ℕ → Bool → ℕ
\end{leancode}


The last two expressions are interpreted as the same expression by \Lean. That is an example of a very powerful feature of \Lean : type inference. \Lean is indeed able to to infer the type of the variables \lean{x} and \lean{b} because it has enough information to do so. In the exemple above, \Lean knows that an argument of the function \lean{not : Bool → Bool} has type \lean{Bool} so \lean{b : Bool}, the same goes for \lean{n : ℕ}. It is however often good practice to precise the type of variable when introducing them. 

To evaluate the output of a function one simply needs to write its arguments separated by whitespaces, without parenthesis :
\begin{leancode}
#eval Nat.add 2 3 --5
#eval (fun n => n + 2) 3 -- 5
\end{leancode}

An import detail about function types is that the arrow \lean{\to} is right associative : for every three types \lean{α β γ : Type*} the types \lean{α → β → γ} and \lean{α → (β → γ)} are the same (but not \lean{(α → β) → γ}.

A second way to create functions is to use the \lean{def} keyword by putting the arguments of the function between parenthesis before the colon.

\begin{leancode}
def add_two (n : ℕ) : ℕ := n + 2
def add (n m : ℕ) : ℕ := n + m

#eval add_two 3 -- 5
#eval add 4 3-- 7
\end{leancode}

To create an abstract undetermined type \lean{α}, one can define then as being of type \lean{Type*} which will "create" a new type for each iteration of \lean{Type*}. Any type can then replace them afterwards.
This notation can of course be used to take types as arguments and create polymorphic functions, as we can see below for the \lean{identity} function :
\begin{leancode}
def identity (α : Type*) (a : α) : α := a
#check identity ℕ -- ℕ → ℕ

#eval identity ℕ 2 --2
#eval identity Bool true --true 
\end{leancode}

However, in the example above having to precise the type \lean{α} in the \lean{identity} function can become tedious and \Lean allows us to avoid that by using \emph{implict arguments}. If the arguments of a function are written between curly braces instead of parenthesis, \Lean will try to infer it from the context.
 This can be especially useful for function which takes types as arguments and can greatly improve readability, see below :
\begin{leancode}
def identity' {α : Type*}  (a : α) := a
#check identity' 2 -- ℕ 
#eval identity' 2 --2

#check identity' true-- Bool
#eval identity' true-- true
\end{leancode}

Finally, readability of \Lean code can also be improved by using variables. The \lean{variable} keyword allows to declare variables for a whole section of a file \footnote{See \href{https://leanprover.github.io/theorem_proving_in_lean4/interacting_with_lean.html}{chapter 6} of \cite{noauthor_theorem_nodate} for definition of sections of a \Lean file}, and every definition can have access to them without having to declare them.
\begin{leancode}
variable (n : ℕ)
def add_two' := n + 2
def add' (m : ℕ) := n + m

#eval add_two 3 -- 5
#eval add 4 3-- 7
\end{leancode}

Implicit arguments can also by declared thanks to the \lean{variable} keyword. For instance, the \lean{indentity''} function declared below is  equivalent to the above \lean{identity'}.

\begin{leancode}
variable {α : Type*} (a : α)

def identity'' := a
#eval identity'' 2 --2
#eval identity'' true-- structures
\end{leancode}

\subsubsection{Structure}

A second way to create new types in \Lean is to use structures. A structure is defined as "a specification of a collection of data, possibly with constraints that the data is required to satisfy" in \cite{noauthor_mathematics_nodate}. For instance, we can define a \lean{Point} structure, made of two coordinates as follows :
\begin{leancode}
structure Point where
  x : ℕ
  y : ℕ
\end{leancode}

Then, an instance of the structure can be created by providing values for the different fields of the structure. For example, to create an instance \lean{point1} of \lean{Point} we proceed as follow :
\begin{leancode}
def point1 : Point where
  x := 5
  y := 3
\end{leancode}

Structure can also take arguments, for instance the type \lean{Prod} of products of two elements is defined as :
\begin{leancode}
structure Prod' (α β: Type*) where
  fst : a
  snd : β

def point1' : Prod' ℕ ℕ where
  fst := 5
  snd := 3
\end{leancode}

Finally, it is possible to access to values of the different fields of instances of structures \textit{via} \lean{<instance>.<field>}, for instance :
\begin{leancode}
#eval point1.x --5
#eval point1'.fst --5 
\end{leancode}

\subsubsection{Type classes}
Another very powerful feature of \Lean are the type classes. This concept allows to associate %endow types with additional "features" 
%This feature allows to greatly simplify readability, by associating a 
"canonical" structures to a type, without having to carry them.

For instance, we can declare a \lean{Group G} instance over a type \lean{G : Type*} as below :

\begin{leancode}
variable {G : Type*} [Group G]
\end{leancode}

This automatically endows the type \lean{G} with a multiplication function \lean{* : G → G → G}, an inverse function \lean{⁻¹ : G → G} and a special element \lean{1 : G} \footnote{The \lean{Group G} instance provides other features, but those will not be used here.} which verifies the axioms of a group :

\begin{leancode}
#check g*g' -- G
#check g⁻¹ -- G
#check (1 : G) --G

example : g * g⁻¹ = 1 := mul_inv_cancel g
example : (g * g') * g'' = g * (g' * g'' ):= mul_assoc g g' g''
\end{leancode}

When \Lean sees a multiplication between elements of type \lean{G} it will try to find a type class instance over \lean{G} that provides a multiplication (here \lean{Group G}) and use the one supplied by that instance. Thus, the user does not have to provide the definition of the multiplication each time they use it.

Concept other than algebraic structures can be formalized through typeclass instances such as topologies, non emptiness or order as we will see next section.

Some types available in Mathlib comes with their own instances, for example, the type \lean{ℕ} comes with \lean{Semiring ℕ} instance\footnote{A semi ring is a triplet $\left( N, +, \times  \right)$ such that $\left( N,+ \right)$ is a commutative monoid, $\left( N, \times  \right)$ is monoid and $\times $ distributes over $+$.}.


\subsection{Some types}%
\label{sub:somtypes}
We here present two types that will be used throughout this report : the \lean{Prop} type used to formalize mathematical propositions and the \lean{Subgroup} type, used to formalize the notion of subgroup.

\subsubsection{The \lean{Prop} type}

In this section we will briefly describe the \lean{Prop} type of \Lean.

This type is used to formalize mathematical propositions and its syntax should be intuitively understood by any person with reasonable knowledge of mathematics : the author makes here the hypothesis that the interpretation of terms such as \lean{∀ n : ℕ, n = 0 ∨ ∃ k : ℕ, n = k + 1} \lean{ : Prop} or \lean{∀ n : ℕ, n > 1 → n ≠ 1 : Prop} should appear clearly to the reader.
    
There are however a few subtleties the author wants to highlight. The first one can already be seen in the last example : the symbol used in \Lean to denote implication is not a double arrow \lean{⇒} but a simple arrow \lean{→}. It actually the same symbol that is used denotes type of functions. That is for a very good reason, both operation are indeed exactly the same in \Lean for reasons which will not explain here but that the interested reader can find in \cite{noauthor_theorem_nodate}. Therefore, implies symbols also associate on the right. 

The second point the author wants to address concerns difference in usage between formalized mathematics and mathematics in natural languages. When a mathematician states that a property $P$ holds as long as two premisses $h_1$ and $h_2$ holds, they will express it in natural language as "if $h_1$ \textbf{and} $h_2$ are true then $P$ is true". It would then be natural to translate the last phrase as $(h_1 \land h_2) \Rightarrow P$ in mathematical language. However, when working with formalized mathematics it is more natural and usual to formulate it as $h_1 \Rightarrow h_2 \Rightarrow P$. Therefore, when seeing propositions of the form \lean{h₁→h₂→...→hₙ→P} one should interpret them as \lean{h₁} and \lean{h₂}, and ... and \lean{hₙ} gives \lean{P}.

The main objective of \Lean as a theorem prover is namely to \emph{prove} these propositions. However, no formalized proof will figure in this report (even though most of the work performed during the internship consisted in formalizing proofs). Indeed, in practice, formalizing proofs makes use of a large diversity of tools, which would need to be explained to the reader. That exercise would require a large amount of efforts for little to no interest for the reader. Moreover, a complex \Lean proof would hardly be readable on paper without an interactive editor. That is why, when referring to a result proven in \Lean we will only state its name and the property it formalizes preceded by the keyword \lean{lemma} or \lean{theorem}. These two keyword are the ones used when formalizing proof. You can find examples below :

\begin{leancode}
/-This is how the results appear in the code-/
theorem eq_zero_or_succ: ∀ n : ℕ, n = 0 ∨ ∃ k : ℕ, n = k + 1 := 
  fun n => Or.elim Nat.eq_zero_or_eq_sub_one_add_one  
    (fun h => Or.inl h) fun h => Or.inr ⟨n-1, h⟩
lemma ne_one_of_le_one : ∀ n : ℕ, n > 1 → n ≠ 1:= fun _ h => ne_of_gt h

/-This is how the results are written in the report-/
theorem eq_zero_or_succ: ∀ n : ℕ, n = 0 ∨ ∃ k : ℕ, n = k + 1
lemma ne_one_of_le_one : ∀ n : ℕ, n > 1 → n ≠ 1
\end{leancode}

Moreover, if a structure has fields of type \lean{Prop} then when defining instances of such structures, the fields of type \lean{Prop} will be replaced by ellipsis as below :
\begin{leancode}
structure EvenNumber where 
  n : ℕ
  even_n : ∃ k, n = 2 * k

/-How it appears in the code-/
def two_even : EvenNumber where
 n := 2
 even_n := ⟨1,mul_one 2⟩

/-How it is written in the report-/
def two_even : EvenNumber where
  n := 2
  ...
\end{leancode}

We finish this subsection by some more syntax. The four \lean{lemma} below are all equivalent to the \lean{lemma}, \lean{ne_one_of_le_one} above and should be interpreted as follows provided with a natural number \lean{n : ℕ} and proof \lean{h} of \lean{n>1} (denoted \lean{h : n > 1}), \lean{ne_one_of_le_one n h} outputs a proof of \lean{n \neq 1}.
\begin{leancode}
lemma ne_one_of_le_one' (n : ℕ) : n > 1 → n ≠ 1
lemma ne_one_of_le_one'' (n : ℕ) (h : n > 1) : n ≠ 1
variable (n : ℕ)
lemma ne_one_of_le_one''' :  n > 1 → n ≠ 1
lemma ne_one_of_le_one''''  (h : n > 1) : n ≠ 1
\end{leancode}

Finally, properties pasted as arguments can be used to infer types :
\begin{leancode}
lemma ne_one_of_le_one''''' {n : ℕ} (h : n > 1) : n ≠ 1
variable (h : n > 1)
#check ne_one_of_le_one n h --n ≠ 1
#check ne_one_of_le_one''''' h --n ≠ 1
\end{leancode}

\subsubsection{The \lean{Subgroup} type}
\label{subsub:subgroup}
In this section we will present the type \lean{Subgroup} defined in \href{https://github.com/leanprover-community/mathlib4/blob/318082b0bccc3abd9d654496f7b60267f277d5fd/Mathlib/Algebra/Group/Subgroup/Basic.lean}{Mathlib.Algebra.Group.Subgroup.Basic}.
The language presented here, in particular the structure of \lean{CompleteLattice} of \lean{Subgroup} will be used throughout the report and the reader should pay great attention to the following lines and read them again if necessary.

The \lean{Subgroup} type can be seen\footnote{This is not actually how the \lean{Subgroup} structure is coded in Mathlib. It instead inherits from the \lean{Submonoid} structure but explaining inheritance here would only add an unnecessary layer of complexity.} as a structure taking a type \lean{G : Type*} with \lean{[Group G]} instance as argument and with four fields : a set of element of \lean{G} named \lean{carrier : Set G}, and proofs that this set is closed under product, contain the element \lean{1 : G} and is closed under the inverse operation of \lean{G} :

\begin{leancode}
structure Subgroup' (G : Type*) [Group G] where
    carrier : Set G
    mul_mem' : ∀ {a b : G}, a ∈ carrier → b ∈ carrier → a * b ∈ carrier
    one_mem' : 1 ∈ carrier
    inv_mem' : ∀ {x : G}, x ∈ carrier → x⁻¹ ∈ carrier
\end{leancode}

Let us consider a type \lean{G : Type*} with a \lean{[Group G]} instance.
The type \lean{Subgroup G} is naturally endowed with a \lean{[CompleteLattice (Subgroup G)]} instance. This instance endows \lean{Subgroup G} with a order \lean{≤ : Subgroup G → Subgroup G → Prop}, a supremum function \lean{⊔ :Subgroup G → Subgroup G → Subgroup G} and a infimum function \lean{⊓ : Subgroup G} \lean{→ Subgroup G → Subgroup G}, a set supremum \lean{⨆ : Set (Subgroup G) → Subgroup G} and a set infimum \lean{⨆ : Set (Subgroup G) → Subgroup G} functions, as well a unique maximal \lean{⊤ : Subgroup G} and a unique minimal \lean{⊥ : Subgroup G} element.

These different all have a very simple mathematical interpretation. The order is the one defined by $H \le K$ if and only if $H$ is a subgroup of $K$ for any two subgroups $H$ and $K$ of \lean{G}.

Therefore, the infimum of two subgroups is nothing more than the intersection of these two subgroups and infimum of a set of subgroup is the intersection of all the subgroups of the set. The supremum of two subgroups is the subgroup generated by the union of these two subgroups and the supremum of a set of subgroup is the group generated by the union of all the groups in the set. Finally, \lean{⊤} and \lean{⊥} the maximal and minimal elements of \lean{Subgroup G} represents the whole group \lean{G} seen as subgroup of itself and the trivial subgroup, respectively.

\begin{remarque}
    When working with relations between subgroups \lean{⊤} will be used to denote the whole group \lean{G}. For instance, if \lean{H} has type \lean{Subgroup G} then \lean{H = G : Prop} states that \lean{H} and \lean{G} are equal as \emph{types} which is false, whereas \lean{H = ⊤ : Prop} states that \lean{H} and \lean{G} are equal as subgroups of \lean{G} which can be true.
\end{remarque}

\section{Groups of Lie type}
\label{sec:BN}

%As said in the introduction, the main obstacle one may encounter working  with groups of Lie type is the lack of a consensual definition. The best way to understand the intuition of what these groups is describe them as groups which "look like Lie groups" but are not necessarily. For instance, the general and special linear groups, as well as the orthogonal and symplectic groups over finite fields are all groups of Lie type.


If the lack of a consensual definition mentioned in the introduction doe not appear to be a real issue when doing pen-and-paper mathematics, it becomes a problem when it comes to formalization. Fortunately, the theory of groups of Lie type provides a powerful tool $BN$-\emph{pairs}. A $BN$-pair over a group $G$ is pair of subgroups of $G$ verifying certain conditions and can be used to state very important results about the structure of the group $G$. Moreover, \emph{every finite group of Lie type} is endowed with such structure and as our work mainly aims at formalizing the \CFSG, this notion makes for an almost perfect foundation for the formalization of groups of Lie type. 
However, working $BN$-pairs in \Lean is not exactly the best solution as it relies heavily on the theory of quotient groups, which is formalized in the \href{https://github.com/leanprover-community/mathlib4}{\lean{mathlib}} library of \Lean but is not pleasant to work with. That is why we introduced an equivalent by more formalization-friendly notion called a $BN\pi$-triplet which makes use of surjection instead of quotient, and which is the one we will use throughout this report.

The goal of this section is to define $BN$-pairs and present some results about the notion of \emph{double cosets}, a basic concept of groups theory bearing strong links with groups of Lie type. This section starts by defining double cosets, $BN$-pairs and $BN\pi$-triplets and present their formalization in \Lean. Then, in \ref{sub:Double Cosets} some results about double cosets and especially doubles cosets of groups with $BN\pi$-triplet are exposed. Finally, these results are put to good use in \ref{sub:GL} to build a $BN\pi$-triplet over the general linear group over a field.

\subsection{Definition}%

\label{sub:Definition}

For this all, report we we fix two groups $G$ and $W$ and in \Lean we declare two variables \lean{G W: Type*} endowed with a \lean{[Group G]} and \lean{[Group W]} instance. We additionally fix two subgroups $B$ and $N$ of $G$ and $\pi$ a group homomorphism from $N$ to $W$.

First and foremost, we need to define the notion of double coset. A concept that, although elementary, is of capital importance to discuss effectively the structure of groups of Lie type. In this subsection, we only give their definition and they will further discussed in \ref{sub:Double Cosets}.

\begin{definition}[Double coset] \label{def:DC}
    A \emph{double coset} of a subgroup $H$ of $G$ is a set of the form $HgH$ for $g \in G$. We  will denote as $C\left( g \right)$ the double coset $BgB$, for $w \in G$. \end{definition} 

    Double cosets are defined in \lean{DoubleCoset.lean} file of the project as
    \begin{leancode}
abbrev DoubleCoset (B : Subgroup G) (w : G) : Set G := 
    {x | ∃ b  b' : B, b * w * b' = x}
    \end{leancode} 
    However, for the sake of readability the notation below was added to the code \footnote{The code presented here allows to write \lean{C} instead \lean{DoubleCoset} in the code.} :
\begin{leancode}
notation "C"  => DoubleCoset 
\end{leancode}

The definition of double coset allow us to introduce the main object of study of this report : $BN$-pairs. 

\begin{definition}[$BN$-pair] \label{BN}
    The couple $\left( B,N \right)$ of subgroups of $G$ forms a \emph{$BN$-pair} over $G$ if it that satisfies the following axioms :
    \begin{enumerate}
        \item $G$ is generated by $B$ and $N$.
        \item the subgroup $T := B \cap N$ is normal in $N$.
        \item The group $N / T$ is generated by a set $S$ of elements of order 2.
        \item For all $n_{i} \in N$ that maps to an element of $S$ under the natural group homomorphism $N \to N / T$, $n_{i}Bni \neq B$.
        \item For all $n_{i}$ as above and all $n \in N, \ $ $n_i B n \subset C(n_in) \cup C(n)$
    \end{enumerate} where $C(g)$ denotes the double coset $BgB$ for $g \in G$.
\end{definition}

\begin{notation}
    If $\left( B,N \right)$ is a $BN-$pair over $G$, we also say that $\left( G, B, N, S \right)$ is a \emph{Tits system}, see for instance \cite{bourbaki_groupes_2007}.
\end{notation}

However, the definition of a $BN$-pair presented above can be impractical to manipulate in \Lean. Indeed, if quotient groups are fully implemented in the \Mathlib library and working with this definition would still be be possible, it is simpler to avoid their use and instead have recourse to surjective group homomorphism.
    This is why we introduced the new and equivalent (see \ref{thm:to pi or not to pi}) structure of a $BN\pi-$triplet.  %We will nonetheless need to use quotient groups later in this work \todo{réf}.

\begin{definition}[$BN\pi$-Triplet] \label{BNpi}
  The triplet $\left( B,N, \pi \right)$ is a \emph{$BN\pi$-Triplet} over the $G$ if it satisfies the following axioms :
    \begin{enumerate}
        \item $G$ is generated by $B$ and $N$.
        \item the subgroup $T := B \cap N$ is the kernel of $\pi$.
        \item $\pi$ is surjective
        \item The group $W$ is generated by a set $S$ of elements of order 2.
        \item For all $n_{i} \in N$ that maps to an element of $S$ through $\pi$, $n_{i}Bni \neq B$.
        \item For all $n_{i}$ as above and all $n \in N, \ $ $n_i B n \subset C(n_in) \cup C(n)$
    \end{enumerate}
\end{definition}


First of all let us show that the two structures are equivalent. This is the point of the following theorem :

\begin{theoreme} \label{thm:to pi or not to pi}
    The group $G$ is endowed with a $BN$-pair structure if and only if it is endowed with a $BN\pi$-structure.
\end{theoreme}

\begin{proof}
    If the group $G$ is endowed with a $BN$-pair structure, it immediately has a $BN\pi$-Triplet with $W = N / (B \cap N)$ and $\pi$ the natural projection $N \to W$.

    Conversely, if $G$ has a $BN\pi$-Triplet structure, then by lifting $\pi$ through the natural projection to $N / \left( B \cap N \right)$ we obtain a group isomorphism $\tilde{\pi} : W \MapsTo N / \left( B \cap N \right)$. Then if $S \subset W$ denotes the generating set of $W$ from the definition of a $BN\pi$-triplet, $\left(G, B, N, \tilde{\pi}^{-1}\left( S \right)  \right)$ is a Tits system.
\end{proof}

The concept of $BN\pi$-triplet is formalized as follow in the \lean{Basic.lean} file :

\begin{leancode}
structure BNpiTriplet (G : Type*) [Group G] (W : Type*) [Group W] where
  B : Subgroup G

  N : Subgroup G
  
  S : Set W

  pi : N →* W

  BN_gen_Group : ⊤ = B ⊔ N

  pi_surj : Function.Surjective pi

  ker_pi_eq_B_subgroupOf_N : pi.ker = B.subgroupOf N

  S_auto_inverse : ∀ s ∈ S, s * s = 1

  top_eq_S_closure : ⊤ = closure S

  left_right_mul_B_neq_B_of_map_S: ∀ ni ∈ pi⁻¹' S,
    ¬ {(ni :G) * (b : G) * ni | b : B} ⊆  B

  subset_union_doubleCosets :  ∀ (n ni : N), ni ∈ pi ⁻¹' S ->
   {ni * b.val * n | b : B} ⊆ C B (ni * n) ∪ C B n
\end{leancode}

\begin{remarque}
    \begin{enumerate}
        \item The term \lean{B.subgroupOf N : Subgroup ↑N} designates the groups \lean{B ⊓ N} seen as a subgroup of \lean{N} instead of \lean{G}.
        \item The property \lean{S_auto_inverse : ∀ s ∈ S, s * s = 1} ensure that every element of \lean{S : Set W} has order at most \lean{2}, and property  \lean{left_right_mul_B_neq_B_of_map_S} ensures that they do not have order \lean{1}.
    \end{enumerate}
    
\end{remarque}

\subsection{Double Cosets}
\label{sub:Double Cosets}

In this section we expose some properties of the double cosets and especially double cosets of groups with a $BN$-pair.

We do not suppose at first that there is a $BN\pi$-triplet over $G$ and state some general facts about double cosets : 

\begin{proprietes} \label{prop:DC1}
    We have the following properties :
    \begin{itemize}
        \item  $C\left( 1 \right) = B$
        \item $\forall g,g'\in G,C\left( g g' \right) \subset C(g) C(g')$
        \item $\forall g \in G, C\left( g^{-1} \right) = C\left( g \right)^{-1}$.
        \item Two double cosets are either equal or disjoints.
    \end{itemize}
\end{proprietes}

\begin{proof}
    The first three points are immediate. 

    Let $g_1, g_2$ be two elements of $G$ such that $C\left( g_1 \right) \cap C\left( g_2 \right) \neq \emptyset$. There exists $b_1, b_2, b'_1, b'_2 \in B$ such that $b_1 g_1 b_1' = b_2 g_2 b'_2 $. Hence, $g = b_1^{-1} b_2 g_2 b_2' b_1'^{-1} \in  C\left( g_2 \right) $ and $C(g_1) = Bg_1B\subset C(g_2)$. By symmetry, we have $C\left( g_1 \right) = C\left( g_2 \right)$, and hence the fourth point.
\end{proof} 

These properties can be found in the \lean{DoubleCoset.lean} file as :
\begin{leancode}
variable {B : Subgroup G}

theorem doubleCoset_one : DoubleCoset B 1 = B.carrier

theorem DoubleCoset.mul_le_mul (g g': G) : C B (g*g') ⊆ C B g * C B g

theorem DoubleCoset.inv (g : G) : (C B g)⁻¹ = C B g⁻¹

theorem DoubleCoset.disjoint_of_neq (g g' :G) (h : C B g ≠ C B g') : 
  Disjoint (C B g) (C B g') 
\end{leancode}

This file also contains some results deriving from the ones above. They have little mathematical interest but make working with double cosets in \Lean more convenient. Some of them can be found below.

\begin{leancode}
lemma DoubleCoset.eq_doubleProd_singleton (g :G) : C B g = B.carrier * {g} * B.carrier

theorem DoubleCoset.self_mem {g : G} : g ∈ C B g

theorem DoubleCoset.eq_of_gen_mem {g g' :G} (h : g ∈ C B g') : C B g = C B g'

theorem DoubleCoset.mul_apply (g g' :G) :
  (C B g) * (C B g') = {x :G| ∃ b1 : B,∃ b2 : B, ∃ b3 : B, b1 * g * b2 * g' * b3 =x}
\end{leancode}

Moreover the link between double cosets and $BN\pi$-triplet appears more clearly through the following properties: 

\begin{proprietes} \label{prop:DC2} \
    \begin{enumerate}
\item For all $g,g' \in G$, we have  $g B g' \subset C(g) \cup C(g'g) $ if and only if $C(g). C(g') \subset C(g) \cup  C(g')$
\item For all $g_i, g$ such that $C(g_i).C(g) \subset C(g) \cup C(g_i g)$
     \[
     C(g_i) C(g) = \begin{cases}
         C(g_ig) \text{ if } C(g) \not \subset C(g_i).C(g)\\
         C(g) \cup C(g_ig) \text{ otherwise}
     \end{cases}
     .\] 
 \item If $g_{i} \in G$ verifies, $g_{i}^2 = 1$,  $g_{i} B g_{i} \subset B \cup C(g_{i})$ and $g_{i} B g_{i} \not\subset B$ then $B \cup C(g_{i})$  is equal to $C(g_i) C(g_i)$ and is a subgroup of $G$.
    \end{enumerate}
\end{proprietes}

\begin{proof}
The first point is immediate, the second follows from the hypothesis and the points 2 and 4 of \ref{prop:DC1}. Concerning the third point, the identity $B \cup C(g_{i}) = C(g_i). C\left( g_i \right)$  follows from the second point in the case $g = g_i$ and $g_i ^2 = 1$, and using this equality it is easy to show that $B \cup C(g_i)$ is a subgroup of $G$.
\end{proof} 

\begin{remarque}
The point 1 of \ref{prop:DC2} can be use to give an alternative statement to point 5 and 6 of \ref{BN} or \ref{BNpi}. The point $6$ can be seen as a very particular case of \ref{thm:GX} and will be used in \ref{sub:GL}. We formalized it as :
\begin{leancode}
def B_union_C_of_simple {s : G} (hs : s*s = 1) (h: {s*b*s | b : B} ⊆ C B s ∪ (C B (s*s)))
    (h' :¬ {s*b*s | b:B} ⊆ B.carrier) : Subgroup G where
  carrier := B.carrier ∪ (C B s)
  ...
\end{leancode}
\end{remarque}

We now suppose that $\left( B,N, \pi \right)$ is a $BN\pi$-triplet over $G$. In \Lean we fix a variable \lean{TS} of type \lean{BNpiTriplet G W}. 

\begin{definition} \label{def:BNDC}
The \emph{double coset} $C'(w)$ of an element $w\in W$ is defined as the double coset $C(n)$ of $B$ for $n \in N$ mapping to $w$ through $\pi$.
\end{definition}

\begin{remark} \

    \begin{itemize}
        \item The set $C'\left( w \right)$ is well defined for all $w \in W$ because using the point 4 of \ref{BNpi} we have $\ker \pi = N \cap B \le B$.
        \item Some authors use the above definition of a double coset to define $BN\pi$-pairs (see for example \cite{bourbaki_groupes_2007}) as the most important results of the theory of groups with $BN$-pair are more conveniently expressed through double cosets of elements $W$ than double cosets of elements of $G$. The theorems \ref{thm:DCD} and \ref{thm:GX} below are good examples of this fact.
However, it is more comfortable to use the definition \ref{def:BNDC} to formalize the property of a certain group having a $BN\pi$-triplet and to first prove properties of double cosets of elements of $G$ and then transfer them to double cosets of elements of $W$.
\end{itemize}
\end{remark}

In order to make the \Lean code more readable, we added \lean{BNpiTriplet.C} defintion that allows to access to \lean{C TS.B n : Set G} by typing \lean{TS.C n : Set G} for any element \lean{n : TS.N}. Then we formalize the above definition as \lean{BNpiTriplet.C'}.
\begin{leancode}
def BNpiTriplet.C (n : TS.N) : Set G := C TS.B n

def BNpiTriplet.C' (w : W): Set G := 
  TS.C (@Classical.choose TS.N (fun n => TS.pi n = w) (TS.pi_surj w))
\end{leancode} 

\begin{commentary} ~\\
\noindent
The function \lean{Classical.choose :{α : Type*} {p : α → Prop} (h : ∃ x, p x)} \lean{ : α} maps to an object \lean{h : ∃ x, p x} for a certain \lean{p : α → Prop} a element of type \lean{α} that verifies \lean{p}.
\end{commentary}

For a convenient use of the double cosets of elements of $W$, we added the following lemmas :

\begin{leancode}
lemma C'_comm_pi (n : TS.N) : TS.C' (TS.pi n) = TS.C n 

lemma C'apply (w : W) : ∃ n ∈ TS.N, TS.C' w = C TS.B n 

lemma C'apply' (w : W) : ∃ n : TS.N, w = TS.pi n ∧ TS.C' w = C TS.B n
\end{leancode}

Most of the properties of double cosets of elements of $G$ can be transferred over double cosets of elements of $W$, for instance we have : 

\begin{proprietes} \label{prop:DC3}
    \begin{itemize}
        \item  $C'\left( 1 \right) = B$
        \item $\forall w,w'\in G, C'\left( w w' \right) \subset C(w) C(w')$
        \item $\forall w \in G, C'\left( w^{-1} \right) = C\left( w \right)^{-1}$.
        \item Two double cosets are either equal or disjoints.
\item $\forall s \in S, \forall w \in W, C'(s). C'(w) \subset C'(s) \cup  C'(w')$
\item For all $s \in S$ and $w \in W$ we have :
     \[
     C'(s) C'(w) = \begin{cases}
         C'(sw) \text{ if } C'(s) \not \subset C'(s).C'(w)\\
         C'(w) \cup C'(sw) \text{ otherwise}
     \end{cases}
     .\] 
    \end{itemize}
\end{proprietes} 

\begin{proof}
    These properties follows from \ref{prop:DC1} and \ref{prop:DC2}.
\end{proof}

We can now use these results to show an important result of the theory of groups with $BN$-pairs : the decomposition of $G$ in double cosets.

\begin{theoreme}[Double coset decomposition] \label{thm:DCD}
    The group $G$ is equal to $B N B = \bigcup_{w \in W} C'\left( w \right)$.
\end{theoreme}

\begin{proof}
    First, let us show that $BNB$ is a subgroup of $G$. It appears immediately that $1 \in BNB$ and $BNB $ is closed by inversion. To prove that $BWB$ is closed under multiplication we will need to prove the following lemma : 
\begin{lemme} \label{lem:BWB}
    Let $s_1, \ldots,s_q \in S$ and $w \in W$. We have
    \[
        C'\left( s_1,\ldots s_q \right). C'(w) \underset{1\le i_1 < ... < i_p \le q}{\subset \bigcup C' ( s_{i_1}\ldots }\ s_{i_p} w )
    .\] 
\end{lemme} 
\begin{proof}
    We prove it by induction, on $q$, the case $q=0$ being trivial. Suppose $q \ge 1 $ and that the lemma holds for $q -1$. Then, we have :
    \begin{align*}
        C'(s_1,\ldots,s_q). C(w) &\subset C'(s_1).C'(s_2,\ldots,s_q).C'(w) &\text{ by point 2 of \ref{prop:DC3}}\\
                                 &\subset C'(s_1) \bigcup_{2\le i_2 < ... < i_p \le q} C'\left( s_{i_2}\ldots s_{i_p} w \right)& \text{ by induction}\\
                                 & \subset \bigcup_{2\le i_2 < ... < i_p \le q} C'\left( s_{i_2}\ldots s_{i_p} w \right) \cup C'\left( s_1 \right)C'\left( s_{i_2}\ldots s_{i_p} w \right) & \text{ by point 6 of \ref{prop:DC3}}\\
                                 &= \bigcup_{1\le i_1 < ... < i_p \le q} C'\left( s_{i_1}\ldots s_{i_p} w \right)
    .\end{align*}
\end{proof}


Let $x,y \in BNB$. There exists $v,w \in W$ such that $x \in C'(v)$ and $y \in C'(w)$. As the set $S$ generates $W$ we have a finite sequence $s_1,\ldots,s_q$ of elements of $S$ such that $v = s_1 \ldots s_q$ and by the above lemma $xy \in C(v).C(w) \subset \bigcup_{1 \le i_1 < ... < i_p \le q} C(s_1\ldots s_q w) \subset BNB$.

Therefore $BNB$ is a subgroup of $G$ that contains both $B$ and $N$, so it is equal to $G$.
\end{proof}

The group $BNB$ appear in the document \lean{basic.lean} as 
\begin{leancode}
def BNB : Subgroup G where
  carrier := TS.B *  TS.N * TS.B
  ...
\end{leancode}

We formalized the theorem \ref{thm:DCD} as lemma \ref{lem:BWB} as  following :
\begin{leancode}
theorem doubleCosetDecomp : ⊤ = BNB TS

theorem simple_prodsubset_union_of_simples' (w : W) {ls : List W} 
 (lsinS :∀ s ∈ ls, s ∈ TS.S): 
  TS.C' ls.prod * TS.C' w ⊆ ⋃ l ∈ { l | l.Sublist ls}, TS.C' (l.prod * w)
\end{leancode}

A more convenient version of \ref{thm:DCD} can be found as :
\begin{leancode}
theorem doubleCosetDecomp' (g : G) : ∃ w, g ∈ TS.C' w 
\end{leancode}



\subsection{Example : the general linear group}
\label{sub:GL}
For this section we fix a natural number $n \ge 2$ and a field $F$.
In a similar fashion, in lean we fix : 
\begin{leancode}
variable {F : Type*} [Field F] [DecidableEq F] 
variable {n : Type*} [Fintype n] [DecidableEq n] 
\end{leancode}

\begin{notation}
    We will denote as $GL_n(F)$ the \emph{general linear groups} \textit{i.e.} the groups of invertible $n \times n$ matrices over the field $F$. In \Lean this groups is denoted \lean{GL n F} and is defined as the group of units of the ring \lean{Matrix n n F} of matrices indexed by the type \lean{n} with coefficients in \lean{F}.
\end{notation} 

The goal of this section is to show that the general linear group $GL_n\left( F \right)$ admits a $BN$-pair by showing that it has a $BN\pi$-triplet structure. In order to do so, we first need to define the notion of monomial matrices.

\begin{definition}[Monomial matrix]
    A \emph{monomial matrix} $M$ is a square matrix with one and only one nonzero coefficient per line and column.
\end{definition}

\begin{propriete} \label{prop:monomial}
    The set of monomial matrices is a subgroup of $GL_n\left( F \right)$ that will be denoted as $N_n(F)$.
\end{propriete}

\begin{proof}
    First, the identity matrix is monomial so $I_n \in N_n(F)$. Next, let $M = \left( m_{i,j} \right)_{i,j \in \{1,\ldots,n\}}$ and $N =\left( n_{i,j} \right)_{i,j \in \{1,..,n\}}$ be monomial matrices. Let $i \in \{1,..,n\}$ and $k_i$ denote the only nonzero coefficient of the $i-$th line of $M$. Then, $p_{i,j}$the coefficient $(i,j)$ of the matrix $P:= M \times N$ is equal to $p_{i,j} = \sum_{k=1}^{n} m_{i,k}n_{k,j} = m_{i,k_i}n_{k_i, j}$ for all $j \in \{1,\ldots,n\}$. Hence, $P$ has only one nonzero coefficient on the $i$-th line : the coefficient on the $j_{k_i}-$th line ; where $j_{k_i}$ is the only nonzero coefficient on the $k_i-$th line of $N$. By a similar reasoning on columns we obtain that $P$ is a monomial matrix.\\
    Finally, the calculations above show that the matrix $M' = \left( m'_{i,j} \right)_{i,j \in \{1,\ldots,n\}}$ defined by $m'_{i,j} = 1 /{m_{j,i}}$ if $m_{j,i} \neq 0$ and $0$ otherwise is the inverse of $M$ and is monomial.
\end{proof}

\begin{implementation}
    In \Lean the property of being monomial is formalized through
    \begin{leancode}
def Matrix.Monomial (M : Matrix n n F) : Prop := 
    (∀ i, ∃! j, M i j ≠ 0) ∧ ∀ j, ∃! i, M i j ≠ 0
    \end{leancode}
    The groups of monomial matrices is defined as the subgroup of \lean{GL n F} made of the invertible matrices who coerce to monomial matrices.
    \begin{leancode}
def MonomialGroup : Subgroup (GL n F) where
  carrier := {M : GL n F | Monomial M.val}
    ...
\end{leancode}

\begin{comment}
    In the above code, the term \lean{M.val : Matrix n n F} designates the underlying matrix of the invertible matrix \lean{M : GL n F}.
\end{comment}
\end{implementation}

The group $N_n\left( F \right)$ will serve as the $N$ subgroup of the $BN\pi$-triplet over $GL_n(F)$. We will now define the $B$ subgroup.

\begin{definition}[Triangular group]
    The \emph{(upper) triangular group} $B_n\left( F \right)$ is the subgroup of $GL_n\left( F \right)$ made of the invertible upper triangular matrices.
\end{definition}

\begin{remarque}
Unless explicitly stated otherwise a triangular matrix denotes an \emph{upper} triangular matrix.
\end{remarque}

The implementation of this group in \Lean is based on the formalization of block triangular matrices, which is already coded in \Mathlib (see \href{https://leanprover-community.github.io/mathlib4_docs/Mathlib/LinearAlgebra/Matrix/Block.html#Matrix.BlockTriangular}{here}) as follows :
\begin{leancode}
variable {α : Type*} [LT α]
def Matrix.BlockTriangular (M : Matrix n n F) (b : n → α) : Prop :=
 ∀ ⦃i j : n⦄, b j < b i → M i j = 0
\end{leancode}

\begin{commentary}\

In the code above, the type \lean{α : Type*} is associated with a \lean{[LT α]} instance. This type class instance endows \lean{α} with a binary relation \lean{< : α → α → Prop} with no particular property.
\end{commentary}

With this we define the groups of block triangular matrices (which depends on the block decomposition given by the parameter \lean{b : n → α}) :

\begin{leancode}
def BlockTriangularGroup (b : n → α ) : Subgroup (GL n R) where
  carrier :=  {M : GL n R | BlockTriangular M.val b }
  ...
\end{leancode}

Now, we endow the type \lean{n} with a \lean{[LinearOrder n]} instance, doing this endows \lean{n} with a \emph{total} order \lean{≤}. We then define the group of triangular matrices as : 
\begin{leancode}
variable [LinearOrder n] 
def  TriangularGroup : Subgroup (GL n F):= BlockTriangularGroup id
\end{leancode}
where \lean{id : n → n} is the identity map. 

Finally, let us define $\pi$ homomorphism that forms the $BN\pi$-triplet over $GL_n(F)$.

If $M \in  GL_n\left( F \right)$ is a monomial matrix, let $f : \{1\ldots,n\} \to  \{1,\ldots,n\}$ be the map that to $j \in \{ 1,\ldots,n\}$ associate the index $f(j)$ such that $M_{f(j), j} \neq 0$, then

\begin{lemme}
    \begin{enumerate}
        \item $f$ belongs to the permutation group $\mathfrak{S}_n$ over $\{1,\ldots,n\}$.
        \item the map 
            \begin{align*}
                \pi : N_n\left( F \right) &\longrightarrow \mathfrak{S}_n \\
                M &\longmapsto \pi (M) = f  
            \end{align*} is a group homomorphism.
    \end{enumerate}
\end{lemme}

\begin{proof}
    The first point is immediate by definition of a monomial matrix and the second follows from the calculations performed in the proof \ref{prop:monomial} to show that $N_n\left( F \right)$ is closed by product.
\end{proof}

The above map is implemented in the \lean{Monomial.lean} file as follows :
\begin{leancode}
def Matrix.toPermFun {M : Matrix n n F} (hM : Monomial M) : n → n :=
  fun j ↦ Classical.choose (hM.2 j).exists_list_transvec_mul_mul_list_transvec_eq_diagonal

def Matrix.toPerm {M : Matrix n n F} (hM : Monomial M) : Perm n where
  toFun := Matrix.toPermFun hM
  ...

def toPermHom : (MonomialGroup : Subgroup (GL n F)) →* Perm n where
  toFun := fun M => toPerm M.2
  ...
\end{leancode}

\begin{commentary} \

    In the above code we first define the function $f$ as \lean{Matrix.toPermFun} for matrices which are monomial. Then \lean{Matrix.toPerm} lift it to an element of \lean{Perm n}, the type of permutation on \lean{n}. Finally, \lean{toPermHom} lift \lean{Matrix.toPerm} a group homomorphism from \lean{MonomialGroup : Subgroup (GL n F)} to \lean{Perm n}.
\end{commentary}

We can now state the following theorem :

\begin{theoreme} \label{thm:GL}
    The subgroups $B_n\left( F \right)$ and $N_n\left( F \right)$ alongside the group homomorphism $\pi : N \to \mathfrak{S}_n$ form a $BN\pi$-triplet over $GL_n\left( F \right)$.
\end{theoreme}
\begin{proof}

Before proving that the first axiom of $BN\pi$-Triplet holds let us introduce one last group.
\begin{definition}[Permutation matrices]
    The \emph{permutation matrix} associated to the permutation $f$ is the matrix $P_f = \left( \delta_{i,f(j)} \right)_{i,j \in  \{1,..,n\}}$.
\end{definition}

Immediately we have the following property : 

\begin{propriete} \label{prop:permmat}
    The permutation matrices are monomial and the map $P : f \mapsto P_f$ is group isomorphism on its image.
\end{propriete}

\begin{proof}
    It is immediately clear that the permutation matrices are monomial and that the map $P$ is injective. Then, the multiplicativity of $P$ can be verified through simple computations.
\end{proof}

In \Lean we first define the map $P$ as the function \lean{PermMatrix : Perm n → Matrix n n F}, then we endow it with a monoid homomorphism \lean{_PermMatrix_Hom : Perm n →* Matrix n n F}. This monoid homomorphism is then lifted to a group homomorphism from \lean{Perm n} to the group of units of \lean{Matrix n n F}, that is \lean{GL n F := (Matrix n n F)ˣ} called \lean{PermMatrix_Hom} \lean{: Perm n →* GL n F}. Finally, \lean{PermMatrixGroup : Subgroup (GL n F)} the group of permutation matrices is defined as the range of that last homomorphism and by restricting this same morphism to its range we obtain the group homomorphism \lean{PermMatrix_Hom' : Perm n →*} \lean{PermMatrixGroup}.
\begin{leancode}
/--The permutation matrix associated to a permutation `f`.-/
def PermMatrix (f : Perm n) : Matrix n n F := 
    Matrix.of (fun i j ↦ if i = f j then 1 else 0)

 /-- PermMatrix seen as a monoid homomorphism from `Perm n` to `Matrix n n R`-/
def _PermMatrix_Hom : Perm n →* Matrix n n F where
  toFun := fun f ↦ PermMatrix f
  ...

/-- The group homomorphism version of `_PermMatrix_Hom`-/
def Matrix.PermMatrix_Hom : Perm n →* GL n F :=
  (_PermMatrix_Hom : Perm n →* Matrix n n F).toHomUnits

/-- The Group of permutation matrices.-/
abbrev PermMatrixGroup : Subgroup (GL n F) := PermMatrix_Hom.range

/--The PermMatrix seen as a group homomorphism from `Perm n` to `PermMatrixGroup`-/
def PermMatrix_Hom' : Perm n →* (PermMatrixGroup :Subgroup (GL n F)) :=
  PermMatrix_Hom.rangeRestrict

\end{leancode}

Now let us show that $\left( B_n(F),N_n(F), \pi \right)$ verify the $BN\pi$-triplet axioms.

\begin{enumerate}
    \item \label{GL1} First we prove that $GL_n\left( F \right)$ is generated by $B_{n}\left( F \right)$ and $N_n\left( F \right)$. To do so, we will use the following result :

\begin{lemme} \label{lem:trans}
    Every matrix in $GL_n\left( F \right)$ can be written as a product of transvection matrices, an invertible diagonal matrix and transvection matrices where transvection matrices are matrices with only 1 as diagonal coefficient and exactly one nonzero nondiagonal coefficient.
\end{lemme}
\begin{proof}
By operation on the lines and columns of the matrix.
\end{proof}

This \href{https://leanprover-community.github.io/mathlib4_docs/Mathlib/LinearAlgebra/Matrix/Transvection.html#Matrix.Pivot.exists_list_transvec_mul_mul_list_transvec_eq_diagonal}{lemma} appears in the \Mathlib library as :
\begin{leancode}
theorem Matrix.Pivot.exists_list_transvec_mul_mul_list_transvec_eq_diagonal 
  (M : Matrix n n F) : ∃ (L : List (Matrix.TransvectionStruct n F)) 
    (L' : List (Matrix.TransvectionStruct n F)) (D : n → F), 
      (List.map Matrix.TransvectionStruct.toMatrix L).prod * M * 
         (List.map Matrix.TransvectionStruct.toMatrix L').prod = Matrix.diagonal D
\end{leancode}

Diagonal matrices being blatantly triangular, we just need to show that  are in $\left<B,N \right>$. Let $c \in F$ and $i,j$ be two distinct elements of $\{ 1,\ldots,n\}$ and let $T_{i,j}\left( c \right)$ denote the transvection matrix of indexes $\left( i,j \right)$ and scalar $c$ as defined in \ref{l'annexe}. If $i<j$, $T_{i,j}\left( c \right)$ is an upper triangular matrix. Otherwise, if $j>i$ then by remarking that $T_{i,j}(c) = P_{\left( i,j \right)} T_{j,i}\left( c \right) P_{\left( i,j \right)}$, we have the result because as just seen $T_{j,i}\left( c \right) \in B_n\left( F \right)$ and by \ref{prop:permmat}, the transposition matrix $P_{i,j}$ is monomial.

In \Lean, we refer to this result as :
\begin{leancode}
theorem MonomialTriangular_gen_GL : 
    (⊤ : Subgroup (GL n F)) = MonomialGroup ⊔ TriangularGroup
\end{leancode}


\item \label{GL2} For the second point let us show that both the intersection of $B_n(F)$ and $N_n\left( F \right)$ and the kernel of $\pi$ are equal to the group $T_n\left( F \right)$ of invertible diagonal matrices. 

    Firstly, all invertible diagonal matrices are clearly triangular so $T_n\left( F \right) \le  B_n\left( F \right) \cap N_n(F)$. Conversely, if $M \in B_n(F) \cap  N_n(F)$, as an invertible triangular matrix, its diagonal coefficients are nonzero, then as a monomial matrix they are the only nonzero coefficients, so $M \in B_n(F) \cap N_n(F)$.

    Secondly, a matrix $M \in GL_n(F)$ belongs to the kernel of $\pi$ if and only if for all index $i \in  \{ 1,..,n\}$ the only nonzero coefficient on the $i$-th line are the diagonal ones \textit{i.e.} if and only if $M \in T_n\left( F \right)$. Therefore, $T_n\left( F \right) = B_n\left( F \right) \cap N_n(F)$.

    Hence, by transitivity of the equality relation we have $\ker \pi = Bn(F) \cap N_n(F)$. That statement is accessed through :
    \begin{leancode}
theorem ker_toPermHom_eq_Diagonal :
  toPermHom.ker = TriangularGroup.subgroupOf (MonomialGroup :Subgroup (GL n F))
    \end{leancode}
    

\item \label{GL3}We will now show that $\pi : N_n(F) \to \mathfrak{S}_n$ is surjective. We will do it by showing that $P : f \mapsto P_f $ is a right section of $\pi$. Indeed, for all $f \in \mathfrak{S}_n$ we saw that the only nonzero coefficient of the $i$-th line, for $i=1,...,n$, is $f(i)$. Therefore, $\pi\left( P_f \right) = f$ and $\pi$ is surjective.We formalized this result in \Lean as:
\begin{leancode}
theorem toPermHom_surj :
  Function.Surjective (toPermHom : (MonomialGroup : Subgroup (GL n F)) →* Perm n)
\end{leancode}

\item A simple induction on $n$ shows that $\mathfrak{S}_n$ is generated by the set $S:= \{\left( i,i+1 \right) | 1\le i\le n-1\}$ and transposition being of order $2$, this proves the fourth point. 

To formalize the definition of the set $S$ (denoted \lean{SuccSwapSet : Set (Perm n)} in \Lean) we need to endow \lean{n} with a \lean{[SuccOrder n]} instance. We then obtain a successor function \lean{succ : n → n} that verifies the following axioms \lean{le_succ : ∀ (a : n), a ≤ succ a}, \lean{ succ_le_of_lt : ∀ {a b : n}, a < b → succ a ≤ b} and \lean{ le_of_lt_succ} ~\lean{: ∀ {a b : n}, a < succ b → a ≤ b} and such that \lean{succ i = i} if and only if \lean{i : n} is a maximal element of \lean{n}.
    We formalize the set $S$ and the above result as :
\begin{leancode}
def SuccSwapSet : Set (Perm n) := {f | ∃ i, i < succ i ∧ f = swap i (succ i) }
theorem top_eq_succ_swap_closure :⊤ = Subgroup.closure (SuccSwapSet : Set (Perm n))
\end{leancode}

\item Let $i \in  \{ 1,..,n-1\}$ and $M_i \in N_n(F)$ maps to $\left( i,i+1 \right)$ through $\pi$. By \ref{GL2} and \ref{GL3} there exists $D \in T_n(F)$ such that $M_i = P_{(i,i+1)} D$. Therefore, $M_i B_n(F) M_i \neq B_n(F)$ if and only if $P_{i} B_n(F) P_{i}\neq B_n(F)$, where $P_i$ denotes the permutation matrix $P_{(i,i+1)}$. As seen in \ref{GL1}, the transvection matrix $T_{i+1,i}(1)$ is equal to $P_{i} T_{i,i+1}(1) P_{i} \in P_{i}B_n(F) P_{i}$. However, $T_{i+1, i}(1)$ is not upper triangular and hence $P_{i} B_n(F) P_{i} \neq B_n(F)$.

    This result appears in our code as :
\begin{leancode}
theorem left_right_mul_Triangular_neq_Triangular_of_map_swap {Ma : MonomialGroup}
 (h : Ma ∈ toPermHom⁻¹' SwapSet) :
   ¬ {Ma * (b.val: GL n F) * (Ma.val : GL n F) | b :  TriangularGroup} ⊆
    (TriangularGroup : Subgroup (GL n F)).carrier
\end{leancode}




\item The final point of the proof is the hardest to prove. We introduce $i \in \{1,\ldots,n-1\}$ and $M_i \in N_n(F)$ as above and we fix a monomial matrix $M \in N_n(F)$. 

    Let us show that $M_i B_n(F) M \subset C(M_iM) \cup C(M) $. Thanks to a reasoning similar to the one above, we only have to prove that  $P_{i} B_n(F) M \subset C\left( P_i M \right)\cup C(M)$ or equivalently $P_i B_n(F) \subset B_n(F) P_i B'_n(F) \cup B_n(F) B'_n(F) $ where $B'_n(F) := M B_n(F)M^{-1}$.

    Let us denote as $G_i$ the subgroup of $GL_n(F)$ consisting of the block diagonal matrices of the form 
    $$\begin{pmatrix} 
        I_{i-1} \\
        & M\\
        & & I_{n-(i+1)}
    \end{pmatrix}$$
    for $M \in GL_2\left( F \right)$.

    This group appear in \Lean as \lean{Gi hii : Subgroup (GL n F)} where \lean{hii : i < succ i} is a proof that an implicit variable \lean{i : n} is less than its successor. The condition \lean{hii} is the natural way to translate in \Lean the condition $i<n$.

    The group $G_i$ is clearly isomorphic to $GL_2\left( F \right)$ and $P_i = 
    \left(\begin{smallmatrix}
        I_{i-1} \\ & 0 & 1 \\ & 1 & 0 \\ & & & I_{n-i-1}
    \end{smallmatrix} \right ) \in G_i$.
Additionally, some simple but very annoying to formalize computations show that $G_i B_n(F) \subset B_n(F) G_i$ and hence $P_i B_n(F) \subset B_n(F) G_i$ so we only need to prove that : 
    $$G_i \subset \left(B_n(F) \cap G_i\right) \ P_i \ \left( B'_n(F) \cap  G_i\right) \ \bigcup \ \left(B_n(F) \cap G_i\right) \ \left(B'_n(F) \cap G\right).$$

    Let $\psi$ denote the natural isomorphism from $GL_2(F)$ to $G_i$. In Lean we formalized it as \lean{GL2toG2ij hij : GL (Fin 2) F ≃* (Gi hii : Subgroup (GL n F)}. To do so we first observe that that $\psi^{-1} \left(B_n(F) \cap G_i \right)$ is the group $B_2\left( F \right)$ of $2 \times 2$ triangular matrices and that $B'_2(F) := \psi^{-1}\left( B'_n(F) \cap G_i \right)$ is either the upper or the lower triangular subgroup of $GL_2\left( F \right)$ depending on whether $\pi\left( M \right) (i) < \pi\left( M \right) (i+1)$ or the opposite.

    

In the first case we need to show that $$GL_2(F) = B_2(F) \cup B_2(F) s B_2 (F)$$ with $s = \left( \begin{smallmatrix}
    0 & 1 \\
    1 & 0
\end{smallmatrix} \right)$.
It is easy to verify using \ref{prop:DC2} that $B_2(F) \cup B_2(F) s B_2 (F)$ is a subgroup of $GL_2(F)$. Additionally, it contains both $B_2(F)$ and $N_2(F)=\{1,s\}$ so as shown in \ref{GL1} it is equal to $GL_2(F)$.

In the second case we have to show that $GL_2 (F) = B_2(F) B_2^{-}(F) \cup B_2(F) s B_2^{-} (F)$ where $B_2^{-}\left( F \right)$ denotes the lower triangular group of $GL_2(F)$. This result is immediate follows from the precedent one by remarking that $B^{-}(F) = s B_2(F) s$.

Hence we have the following statement in Lean :
\begin{leancode}
theorem GLsubset_union_doubleCosets : ∀ (M Ma : MonomialGroup), ∀ s ∈ SwapSet, 
 toPermHom Ma = s ->
  {(Ma.val * b.val * M.val : GL n F) | b : (TriangularGroup : Subgroup (GL n F))} ⊆
      C TriangularGroup (Ma * M).val∪ C TriangularGroup M.val 
\end{leancode}
\end{enumerate}

\begin{implementation}\

Formalizing the above proof of \ref{thm:GL} allows us to build an object \lean{GeneralLinearGroup_BNpiTriplet} of type \lean{BNpiTriplet (GL n F) (Perm n)} as follows :      
\begin{leancode}
/--The `BNMphiQuadruplet`  structure over `GL n F`.-/
noncomputable
def GeneralLinearGroup_BNpiTriplet : BNpiTriplet (GL n F) (Perm n) where
  B := TriangularGroup
  N := MonomialGroup
  S := SwapSet
  pi := toPermHom
  BN_gen_Group := TriangularMonomial_gen_GL
  pi_surj := toPermHom_surj
  ker_pi_eq_B_subgroupOf_N := ker_toPermHom_eq_Diagonal
  self_inverse_of_mem_S := self_inverse_of_mem_SwapSet
  top_eq_S_closure := top_eq_swap_closure
  left_right_mul_B_neq_B_of_map_S := 
    fun _ h => left_right_mul_Triangular_neq_Triangular_of_map_swap h
  subset_union_doubleCosets := GLsubset_union_doubleCosets'
\end{leancode}
\end{implementation}
\end{proof}

\section{Some results on groups with a $BN$-pair}
\label{sec:somres}
This section present some of the main results that have been formalized on groups with $BN\pi$-triplet during this internship. However, as it will be discussed in \ref{subsub:Coxeter2} note all of the results necessary to prove the simplicity theorem \ref{thm:simple} have been proven due to the need for a more advanced theory of Coxeter groups than the one currently available in \Mathlib. Thus, most of the results presented in this part will not be proven.

This section first starts by presenting a way to endow with a $BN\pi$-triplet certain quotients of groups with $BN\pi$-triplet. Then after an introduction to the theory of Coxeter groups, we will the link of such groups with groups with $BN\pi$-triplet. Finally, a few results concerning the subgroups of $G$ that contains $B$ or one of its conjugates will be exposed. 

\subsection{Quotient $BN\pi$-triplet}

    Let $Z$ be a normal subgroup of $G$ contained in $B$. Let us denotes as $\hat{G}$ the group $G /Z$, as $\hat{B}$ the groups $B/{Z}$, as $\hat{N}$ the group $N/(N\cap Z)$ and as $\hat{\pi}$ the lift of $\pi$ through the natural homomorphism $N \to (N \cap Z)$. Then we have :

\begin{definition}[Quotient $BN\pi$-triplet] \label{def:quotBN}
$\left( \hat{B},\hat{N},\hat{\pi} \right)$ forms a $BN\pi$-triplet over $\hat{G}$ called the quotient $BN\pi$-triplet of $\left( B,N, \pi \right)$ by $Z$.
\end{definition}

 If proving this theorem does not require much efforts\footnote{and we incite the reader to do so}, formalizing it is a bit more arduous. That is why we introduced the structure of image $BN\pi$-triplet :

\begin{definition}[Image $BN\pi$-triplet]
Let $G'$ be a group, $p$ a surjective homomorphism from $G$ to $G'$ and $\pi': p(N) \to W$ a group homomorphism. If $\ker p \le B$ and $\pi' \circ p = \pi$ then $\left( p(B), p(N), pi' \right)$  forms a $BN\pi$-triplet over $G'$ called the image $BN\pi$-triplet of $(B,N, \pi)$ by $p$.
\end{definition}

It appears clearly from the definitions above that if $Z \le B$ is normal in $G$ then the quotient $BN\pi$-triplet of $\left( B,N, \pi \right)$ if nothing more than the image $BN\pi$-triplet of $\left( B,N, \pi \right)$ by the natural homomorphism $G \to G / Z$. Thus, we can use image $BN\pi$-triplet to formalize quotient $BN\pi$-triplet and that is how we proceeded :

\begin{leancode}
variable (G' : Type*) [Group G']

def ImageBNpiTriplet {p : G →* G'} (p_surj: Surjective p) (ker_p_le_B : p.ker ≤ TS.B)
    {p' : TS.N →* TS.N.map p} (p'_rest_p : ∀ n, p n.val = (p' n).val) {pi': TS.N.map p →* W}
      (p_comm_pi' : TS.pi = pi'.comp p') : BNpiTriplet G' W where
  B := TS.B.map p
  N := TS.N.map p
  pi := pi'
  S := TS.S
  ...

noncomputable
def QuotientBNpiTriplet (Z : Subgroup G) [Normal Z] (ZleB : Z ≤ TS.B): BNpiTriplet (G ⧸ Z) W :=
    ImageBNpiTriplet TS (QuotientGroup.mk'_surjective Z) ...
\end{leancode}

\begin{commentary}
    \begin{itemize}
        \item
    The definition of \lean{ImageBNpiTriplet} may seem verbose and ask for more argument than necessary. It is true but it makes the formalization easier. 

\item The term \lean{QuotientGroup.mk'_surjective Z} of type \lean{Function.Surjective} \lean{⇑(QuotientGroup.mk' Z)} used in the definition of \lean{QuotientBNpiTriplet} is a proof that \lean{QuotientGroup.mk' Z: G → G ⧸ Z}, the natural homomorphism from $G$ to $G / Z$ is surjective.
    \end{itemize}
\end{commentary}


\begin{ex}
    In the case of $G = GL_n(F)$, the center $Z$ of $GL_n(F)$ is normal in $GL_n(F)$ and is equal the group of nonzero scalar matrices and as such $Z \le B_n(F)$. Therefore, the quotient $BN\pi$-triplet of $\left( B_n(F),N_n(F), \pi \right)$ by $Z$ forms a $BN\pi$-triplet over $PGL_n\left( F \right) := GL_n(F)/Z$.
    One can find this fact formalized in \lean{GLn.lean}\footnote{The definition of \lean{PGL} is not present in Mathlib and was coded for this project, you can find it defined in the \href{https://github.com/corent1234/BNpairs/blob/master/finite_groups_of_Lie_type/FiniteGroupsOfLieType/GLn/GLn.lean}{\lean{GLn.lean}} file} as :
\begin{leancode}
noncomputable
def ProjectiveGeneralLinearGroup_BNpiTriplet : BNpiTriplet (PGL n F) (Perm n) :=
  QuotientBNpiTriplet (GeneralLinearGroup_BNpiTriplet n F) (Subgroup.center (GL n F)) ...
   
\end{leancode}  
\end{ex}


\subsection{Relations with Coxeter groups}

    Coxeter groups are an important family of abstract groups which have been intensively studied since their introduction by H. S. M. Coxeter in 1934 in \cite{coxeter_discrete_1934}. 
   Lots of important results have been discovered concerning these groups (see §1 of \cite{bourbaki_groupes_2007}, for instance), results which can be used to get more insights on the structure of groups with $BN\pi$-triplet.
   Indeed, as we will see in \ref{subsub:Coxeter2} if the group $G$ has $BN\pi$-triplet with $\pi : G \to W$ then $W$ is a Coxeter group and this additional property of $W$ is especially useful to highlight even more the link between groups with $BN\pi$-triplet and double cosets. However, this link will not be really put forward in this report for reasons explained in \ref{subsub:Coxeter2} but can be found in \cite{bourbaki_groupes_2007}.
    This subsection first presents the definition and some basic properties as well as the \Lean implementation of Coxeter groups, and then the link with groups with $BN\pi$-triplet is discussed.

\subsubsection{Introduction to Coxeter theory}

We present here a few basic definition of the theory of Coxeter groups. These elements were already implemented in \Mathlib were not coded by the author during its the internship. They are available \href{https://github.com/leanprover-community/mathlib4/tree/5dccde47166d00d485a5d6ad8cc3cb4431edcb38/Mathlib/GroupTheory/Coxeter}{here}. 

Let $W$ be a group and $S$ a subset of elements of order $2$ of $W$.
For all two elements $s, s' \in  S$, we define $m(s,s') \in  \mathbb{N}$ to be the order of the product $ss'$ if it is finite and $0$ otherwise.

\begin{definition}[Coxeter system]
    We say that the couple $(W,S)$ is a \emph{Coxeter system} if the generating set $S$ alongside with the relations $(ss')^{m\left( s,s' \right)} = 1$ for all $s,s' \in S$, forms a presentation of $W$.
\end{definition}

When $\left( W,S \right)$ is a Coxeter system, the elements of $S$ are called simple (reflections) and by an abuse of language, $W$ is called a \emph{Coxeter group}.

\begin{ex}\

    \begin{enumerate}
        \item  For all natural number $n$, $\mathfrak{S}_n$, the symmetric group over $\{1,\ldots,n\}$ with the set of transposition $(i,i+1)$ for $1\le i \le n $ forms a Coxeter system.
        \item Let $m$ be a natural number, let $s$ denote the symmetry of the complex plane over the real line and $r$ the rotation of angle $\frac{2i \pi}{m}$. The dihedral group $D_{2m} := \left<r,s\right>$ alongside with $S= \{r,s\}$ is a Coxeter System. 
    \end{enumerate}
\end{ex}

The Lean implementation \lean{CoxeterSystem} of a Coxeter system does not make a direct use of the above definition but is in fact based upon the following concept of a Coxeter matrix :

\begin{definition}[Coxeter matrix]
    Let $A$ be a set. A square symmetric matrix $M = \left( m_{a,a'}\right)_{a,a' \in A}$ with coefficient in $\mathbb{N}$ is a \emph{Coxeter matrix} of type $A$ if it satisfies 
\begin{itemize}
    \item $\forall  a \in A, m_{a,a} = 1$
    \item $\forall a,a' \in  I, a \neq  a' \Rightarrow m_{a,a'} \neq 1$
\end{itemize}
 
    If $\left( W,S \right)$ is a Coxeter system, then the matrix $M = \left( m\left( s,s' \right) \right)_{s,s' \in  S}$ is a Coxeter matrix of type $S$ called the Matrix of $\left( W,S \right)$.
    %and $(s_a)_{a \in A}$ denote the family of all the elements of $S$ indexed by $A$. We say call the matrix $M = \left( m\left( s_a, s_b \right) \right)_{a,b in A}$ the \emph{Coxeter matrix} of type $A$.
\end{definition}

\begin{proof}
    Suppose that $\left( W,S \right)$ is a Coxeter system. It is immediate that $m\left( s,s \right) = 1$, and $m(s,s') \ge  2$ for all $s,s' in S$. Additionally, $s.s' = (s'.s)^{-1}$ and therefore $\left( m\left( s,s' \right) \right)_{s,s' \in  S}$ is symmetric.
\end{proof}

The Lean implementation of Coxeter matrices is pretty straightforward and does not need any commentary (the \lean{by decide}s can be ignored):
\begin{leancode}
structure CoxeterMatrix (A : Type*) where
  /-- The underlying matrix of the Coxeter matrix. -/
  M : Matrix A A ℕ
  isSymm : M.IsSymm := by decide
  diagonal i : M i i = 1 := by decide
  off_diagonal i i' : i ≠ i' → M i i' ≠ 1 := by decide
\end{leancode}

\begin{definition}[Group of a Coxeter matrix]
    The \emph{group  $G(M)$ of a Coxeter matrix} $M$ of type $A$ is the presented group with generator $A$ and relations $(a.a')^{m\left( a,a' \right)} = 1$ for all $a,a' \in A$. 
\end{definition}

In Lean, if \lean{M} has type \lean{CoxeterMatrix A} for a certain type \lean{A} its group is denoted as \lean{M.Group}. Additionally, the generators of the group \lean{M.Group} can be accessed through the function \lean{M.simple : A → M.Group} mapping each element of type \lean{A} to its image in the group of \lean{M}. This group also verifies the following properties :

\begin{propriete}

\begin{enumerate}
    \item If $M$ is a Coxeter matrix of type $A$, for $A$ a set, then $\left( G\left( M \right),A \right)$ is a Coxeter system.
    \item $\left( W,S \right)$ is a Coxeter system if and only if there exists a set $A$ and a Coxeter matrix $M$ of type $A$, and an isomorphism $f : G\left( M \right) \to W$ sending bijectively $A$ to $S$. 
    %\item Let $\left( W,S \right)$ and $\left( W', S' \right)$ be two Coxeter systems such that there exists a Coxeter matrix $M$ of type $A$, and groups isomorphisms $f : G(M) \to  W$ and $f' : G\left( M \right) \to W'$ sending $A$ to $S$ ad $S'$ respectively. Then there exists a group isomorphism $ \phi : W \to W'$ sending 
\end{enumerate}
\end{propriete}
   
\begin{proof}

The proof of 1. follows from the definition of $G\left( M \right)$.
If $\left( W,S \right)$ is a Coxeter system then its Coxeter matrix $M$ fits and we have $ W \simeq G(M)$ by definition of a Coxeter system. The converse implication is immediate from the definition of a Coxeter matrix.

\end{proof}
Let $M$ be a matrix of type $A$ and an isomorphism $f : G(M) \MapsTo W$ sending $A$ to $S$. Then the latter proposition tells us that the couple $\left( M,f \right)$ characterizes the Coxeter system structure on $\left( W,S \right)$. This fact serves as the definition of a Coxeter system in Lean. 
Indeed, given a type \lean{A}, an element \lean{M} of type \lean{CoxeterMatrix A} and a type \lean{W} endowed with a group structure, an element of type \lean{CoxeterSystem M W} consists in the data of a group isomorphism between \lean{W} and \lean{M.Group}.

\begin{leancode}
structure CoxeterSystem {A : Type*} (M : CoxeterMatrix A) (W : Type*) 
    [Group W] where
  /-- The isomorphism between `W` and the Coxeter group associated to `M`. -/
  mulEquiv : W ≃* M.Group
\end{leancode}


\subsubsection{BN-pairs and Coxeter theory}
\label{subsub:Coxeter2} 

This subsection details the relations between Coxeter groups and groups with $BN$-pair, they all derives from the following theorem :
\begin{theoreme} \label{thm:Coxeter}
    $\left( W,S \right)$ is a Coxeter system.
\end{theoreme}
 The proof of the above theorem can be found in \cite{bourbaki_groupes_2007} §2 n°4 and is a consequence of the decomposition of $G$ in double cosets (see theorem \ref{thm:DCD}). However, like many of the results that will be described from now on, it makes a heavy use of parts of the theory of Coxeter groups that are not yet in implemented in \Lean.
    
 As proving all the results needed might necessitate a whole other internship, it was decided to leave the task of formalizing them for future works and focus the goal of proving the simplicity theorem (theorem \ref{thm:simple}). The \Lean code is therefore filled with holes. However, every proof that did not make a direct use of the Coxeter group theory has been formalized, and the full list of the necessary results and where they are needed in the code is available on \href{https://github.com/corent1234/BNpairs}{github}.

 Additionally, proving the results mathematically in this report would not be of great interest, as it would either necessitate a large amount on the Coxeter group theory to be exposed -which was not the object of this internship- or that the proofs given would be filled with references to other works. That is why what follows will mostly consists in definitions and statements of theorems with the notable exception of theorem \ref{thm:simple}.

The first property that necessitate advanced Coxeter group theory to be proven is the very fact that $\left( W,S \right)$ is a Coxeter system. We "formalized" it with the use of \lean{sorry} \footnote{The reader unfamiliar with the implementation of Coxeter groups in \Lean should not pay much attention to the following lines and only keep in mind that used \lean{sorry} to provide a Coxeter group structure over \lean{W}.}. The term \lean{sorry} produce an unknown term of the expected type. It is often used as a placeholder for results waiting to be formalized.

\begin{leancode}
def BNpiTriplet.coxeterMatrix  (TS : BNpiTriplet G W) : CoxeterMatrix TS.S where
  M := Matrix.of fun s s' => orderOf (s*s' : W)
  ...

def  BNpiTriplet.cs : CoxeterSystem TS.coxeterMatrix W where
  mulEquiv :=sorry

abbrev BNpiTriplet.length (TS : BNpiTriplet G W) := TS.cs.length

abbrev BNpiTriplet.simple (TS : BNpiTriplet G W) := TS.cs.simple

lemma simple_id_mem_S : TS.simple = fun s => s.val := sorry
\end{leancode}

Using the above theorem\footnote{The proof only really makes use of the notion of \emph{length} of an element, which is defined for every group generated by elements of order $2$, but is only implemented in \Lean in the Coxeter groups. However, introducing the whole theory of length for only one proof would require  important efforts for both the reader and he author for very limited interest. For more information around this subject we once again send to \cite{bourbaki_groupes_2007}.} we have the following: 

\begin{lemme}
    The map sending an element $w \in W$ to its double coset $C'\left( x \right)$ is bijective.
\end{lemme}

This appears in \Lean as \lean{Weyl_doubleCosets_equiv : W ≃ Set.range TS.C'} and makes use of the lemma \lean{C'_inj' : Function.Injective TS.C'} which might of interest for some readers planning to build over the code presented here.

\subsection{Subgroups of $G$}

This subsection present a few results around subgroups of $G$ containing $B$ or conjugates of $B$.

Let $X$ be a subset of $S$. We denote as $W_X$ the group generated by $X$. In \Lean  we represent $X$ by an object \lean{X} of type \lean{Set TS.S} and $W_X$ is the term \lean{Subgroup.closure X : Subgroup W}. We have :
\begin{theoreme} 
    The set $G_X := \bigcup_{x \in W_x} C'\left( x \right)$ is a subgroup of $W$ that contains $B$.
\end{theoreme}

In \Lean we the groups $G_X$ are formalized through :

\begin{leancode}
def DoubleCoset_of_Set ( X : Set TS.S) : Subgroup G where
  carrier := ⋃ x ∈ closure (X : Set W), TS.C' x
  ...
\end{leancode}

The importance of these groups appears in the following theorem :

\begin{theoreme} \label{thm:GX}
     
    The map \vspace{-0.2cm}
\begin{align*}
\mathcal{P}\left( S \right) &\longrightarrow \{\text{Subgroups of $G$ containing $B$}\} \\
X &\longmapsto G_X 
.\end{align*}
    is bijective. 
\end{theoreme}

The above bijection can be accessed in lean \textit{via} \lean{DoubleCoset_of_Set_bij : Set TS.S ≃} \lean{{H :Subgroup G // TS.B ≤ H}}. This is a great example of the deep connection between the structure of the group $G$ and the double cosets $C'$ over $B$.

Now we introduce the definition of parabolic subgroups as below :

\begin{definition}
    A subgroup $P$ of $G$ is said \emph{parabolic} if it contains a conjugate of $B$.
\end{definition}

    The Parabolic subgroups are formalized as :

\begin{leancode}
def Subgroup.Parabolic (P : Subgroup G) : Prop := ∃g, ConjugatedSubgroup TS.B g ≤ P
\end{leancode}
where \lean{ConjugatedSubgroup TS.B g : Subgroup G} is the subgroup of \lean{G} with \lean{carrier :=} \lean{{w} * B.carrier * {w⁻¹}}.

Before, stating the only result on parabolic groups of this report we will recall the definition of the normalizer of a subgroup.

\begin{definition}
    The normalizer of a subgroup $H$ of $G$ is the largest subgroup of $G$ in which $H$ is normal.
\end{definition}

The normalizer of an object \lean{H : Subtype G} is denoted \lean{H.normalizer : Subgroup G} in \Lean. We can now state the following theorem :
\begin{theoreme}\label{thm:parabolic}
    A parabolic subgroup $P$ is its own normalizer.
\end{theoreme}

This theorem has been formalized as \lean{eq_normalizer_of_parabolic {P : Subgroup G}} \lean{(h : P.Parabolic TS) : P = P.normalizer}. It will bu sed with the following lemma to prove \ref{thm:simple}. The latter is, moreover, more of a technical lemma to prove \ref{thm:simple} than an actual result.

\begin{lemme} \label{lem:2}
Let $H \triangleleft G$. There exists $X \subset S$ such that $BH = G_X$ and every element of $X$ commute with every element of $S \setminus X$.
\end{lemme}

\section{The simplicity theorem}%
\label{sec:simple}

In this section we state and prove a theorem that can be used to show that groups with $BN\pi$-triplet are simple when applicable. Then we apply this theorem to case of the projective special linear group over a field.

\subsection{The theorem}

    Let $U$ be a normal subgroup of $B$. We define $Z$ to as the group $Z := \bigcap_{g \in G} g B g^{-1}$, and we denote as  $G_1$ the subgroup $G_1 := \bigsqcup_{g \in G} g U g^{-1}$ of $G$.

\begin{theoreme} \label{thm:simple}
If the following conditions are verified :
\begin{enumerate}
    \item \label{simple1} $B = UT$
    \item \label{simple2} The only perfect quotient group of $U$ is the trivial  group, or in other words for all strict normal subgroup $V$ of $U$,  $U / V \neq  [ U / V, U/V]$.
    \item \label{simple3}$G_1$ is perfect \textit{i.e. } $G_1$ is equal to its derived subgroup $[G_1,G_1]$.
    \item \label{simple4} the Coxeter system $\left( W,S \right)$ is irreducible \textit{i.e.} there is no subset $X$ of $S$ such that every element of $X$ commutes with every element of $S-X$.
\end{enumerate} 
    then $G_1 / \left( Z \cap G_1 \right)$ is either trivial or simple noncommutative.
\end{theoreme}

\begin{corollary} \label{cor:2}
    If $U \cap Z = \{1\}$ then $Z \cap G_1$ is the center of $G_1$.
\end{corollary}

\begin{proof}
    As both $Z$ and $U$ are normal in $B$, every element of $Z$ commutes with every element of $U$, thus with every element of $G_1$. Then, the result follows from the above corollary.
\end{proof}

\begin{proof}[Proof of the theorem]

Let us show that every subgroup $H$ of $G$ normalizing $G_1$ is either contained in $Z$ or contains $G_1$.

    We first show that $G_1T$ is equal to $G$. To do so we need to observe that $G_1T$ is subgroup of $G$ that contains $B$ so by \ref{thm:parabolic} it is its own normalizer. Therefore, as $N$ normalizes $G_1$ and $T$, and so $G_1T$, we have $N \le G_{1}T$. Thus, as $B$ and $N$ generates $G$ we have $G = G_1T$.

    \begin{lemme} \label{lem:subBN}
        Let us set $G' := G_1 H$, $B' := B \cap G'$, $N' := N \cap G'$ and $\pi' := \pi_{|N'}$. 
        Then $\left( B', N', \pi' \right)$ forms a $BN\pi$-triplet over $G'$.
    \end{lemme}
    \begin{proof}
        First and foremost, remark that $G'T = G$ because $G_1 \le G'$ and therefore, $N'T = N$.
        \begin{enumerate}
            \item The relations $B=UT=TU$ allows to rewrite theorem \ref{thm:DCD} as $G = UNU$. Then $U$ being a subgroup $G'$, we have $G' = UN'U$ and therefore $G' = \left<B'_n(F),N' \right>$ because $U \le B'$.
            \item The kernel of $\pi' = \pi_{|N'}$ is equal to $\ker pi \cap N' = B \cap N \cap N' = B' \cap N' $.
            \item The surjectivity of $\pi'$ is direct consequence of the surjectivity of $\pi$ and the relations $N=N'T$ and $\ker \pi = T$.
            \item Immediate.
            \item Let us denote as $W'$ the group $W' := \pi (N) =  \Im \pi'$. For all $w \in w'$, we have $Bw'B = Bw'B'$ because $B = B'T$ so $BwB \cap G' = B'w'B'$. The result is then immediate.
            \item Immediate.
        \end{enumerate}
    \end{proof}

   $H$ is normal in $G_1 H$\ thus, there exists $X \subset S$ such that $B'H = B' W_X B'$ and every element of $X$ commute with every element of $S-X$ (see \ref{thm:parabolic}). However, the Coxeter system $\left( W,S \right)$ is irreducible so $X = \emptyset$ or $X = S$.

     \underline{First case : $X = \emptyset$} \textit{i.e.} $B' H = B'$ so $H \le B' \le B$. Additionally, for all $g \in G$ we have $g_1 \in G_1$ and $t \in T$ such that $g = g_1 t$, so $H$ being normal in $G_1$, $H \subset g_1 B g_1^{-1}$ and thus $H \subset g B g^{-1}$ as $T \le B$. Therefore, $ H \subset Z$.

     In particular, $G_1$ normalizes itself so $G_1 / \left( G_1 \cap Z \right)$ is trivial.

    \underline {Second case $X = S$ :} \textit{i.e.} $B'H = G'$ and so $G = G'T= B'HT = HB'T = HB.$

       As $U \triangleleft B$ all conjugates of $U$ are of the form $h U h^{-1}$ with $h \in  H$ which means they are all subgroups of $UH$. Thus $G_1 \subset UH$ and 
       $$U / \left( U \cap  H \right) \simeq UH / H = G_1H / H \simeq G_1 / \left( G_1 \cap H \right).$$

The group $G_1$ being perfect, its quotient $G_1 / \left( G_1 \cap H \right)$ also is. Thus, $U / (U \cap H)$ also is perfect and as such, it is by hypothesis the trivial group. Therefore, $G_1 = G_1 \cap H$ \textit{i.e.} $ G_1 \le H$.

Thus $G_1 / \left( G_1 \cap Z \right)$ is simple and as $G_1$ is perfect $G_1 / \left( G_1 \cap Z \right)$ also is and therefore cannot be commutative.
\end{proof}

The above theorem appears in \Lean as :
\begin{leancode}
def BNpiTriplet_SimplictyTheorem'  {U : Subgroup G} (hU : U ≤ TS.B) (hU' : (U.subgroupOf TS.B).Normal) 
 (hUT : ⊤ = mul_Subgroup' hU' (TS.T.subgroupOf TS.B)) (RU : propR U) (hirred : TS.cs.irreducible)
  (perfectG1 : ⁅ (⊤ : Subgroup (ConjSubgroup U)), ⊤⁆ = (⊤: Subgroup (ConjSubgroup U)))
   [Nontrivial (ConjSubgroup U⧸ ((⨅ g, ConjugatedSubgroup TS.B g).subgroupOf (ConjSubgroup U))) ] :
    IsSimpleGroup (ConjSubgroup U⧸ ((⨅ g, ConjugatedSubgroup TS.B g).subgroupOf (ConjSubgroup U)))
\end{leancode}

\begin{remark}
    The $BN\pi$-triplet defined in the lemma \ref{lem:subBN} has been formalized in \Lean as :

\begin{leancode}
variable {U : Subgroup G} (hU : U ≤ TS.B) (hU' : (U.subgroupOf TS.B).Normal)
variable (hUT : ⊤ = mul_Subgroup' hU' (TS.T.subgroupOf TS.B))
variable {H : Subgroup G} (hH : ConjSubgroup U ≤ H.normalizer)

def SubBNpiTriplet : BNpiTriplet (Subgroup_mul  hH) W where
  B := TS.B.subgroupOf (Subgroup_mul hH)
  N := TS.N.subgroupOf (Subgroup_mul hH)
  pi := TS.pi.comp (N'toN TS)
  S := TS.S
  ... 
\end{leancode}
\end{remark}

\subsection{Application : the projective special linear group}

We denote as $SL_n(F)$ the \emph{special linear group} over $F$ \text{i.e.} the kernel of the group homomorphism $\det : GL_n(F) \to R^*$ and as $PSL_n(F)$ the quotient of $SL_n(F)$ by its center, which is named the \emph{projective special linear group}.
These groups are (surprisingly) denoted \lean{SL n F} and \lean{PSL n F} in \Lean. We can apply the theorem \ref{thm:simple} alongside with its corollary \ref{cor:2} to show : 

\begin{theoreme}
    If $n \ge 3$ or $n = 2$ and $|F| \ge 4$ then the group $PSL_n\left( F \right)$ is simple.
\end{theoreme}

\begin{proof}
    Let $U$ denotes the strictly upper triangular group \textit{i.e.} the subgroup of $GL_n(F)$ made of the triangular matrices whose every diagonal entry are $1$. It is a normal subgroup of the triangular matrices. 
    We set $Z := \bigcap_{M \in GL_n(F)} M B_n(F) M^{-1}$ and $G_1 := \bigsqcup_{M \in GL_n(F)} M U M^{-1}$. 
    First, let us show that $G_1 = SL_n\left( F \right)$. Every element of $G_1$ is blatantly of determinant $1$ so now let us show that $SL_n\left( F \right) \le G_1$ by using the following lemma :
    \begin{lemme}
        $SL_n\left( F \right)$ is generated by the transvection matrices.
    \end{lemme}

    \begin{proof}
        By the lemma \ref{lem:trans}, we only need to prove that diagonal matrices of determinant $1$ can be written as products of tranvection matrices. This is easily proven by operations over the lines and colums.
    \end{proof}
    The transvection matrices being either strictly upper triangular matrices or conjugates of strictly upper triangular matrices by transposition matrices as seen in the point 1 of the proof of \ref{thm:GL}, by the above lemma, $G_1 = Sl_n(F)$.
    Now let us prove that the groups defined above verify the hypothesis of \ref{thm:simple}.

    \begin{enumerate}
        \item A simple calculation shows that the diagonal of a product of triangular matrices is the product of their diagonal. Hence, for all triangular matrix $T$, if we denote as $D$ the diagonal the matrix of its diagonal coefficient, which is invertible so in $T_n\left( F \right)$ then the matrix $T' := TD^{-1}$ is strictly upper triangular and therefore $T = T' D \in UT$.
        \item By computing the iterated derived subgroups of $U$ one can show that $U$ is solvable, and therefore verifies the second hypothesis of theorem \ref{thm:simple}.
        \item Let us show that $G_1 = SL_n\left( F \right)$ is perfect under the conditions of the theorem by proving that transvection matrices can be written as commutators and using the lemma \ref{lem:trans}.

            Let $i,j$ be distinct elements of $n$ and $c$ be an element of $F$.

            If $n\ge 3$ then we can find an index $k \in n$ distinct from $i$ and $j$ and $T_{i,j}\left( c \right)= [T_{i,k}(c), T_{k,j}(1)]$.

            Otherwise, if $n=2$ then, for all $x, y \in F$
    $$\left[ \begin{pmatrix} x & 0 \\ 0 & x \end{pmatrix}, \begin{pmatrix} 1 & y \\ 0 &1 \end{pmatrix} \right] = \begin{pmatrix} 1 & (x^2-1) y \\ 0 & 1 \end{pmatrix}.$$
    The equation $c = \left( x^2 -1  \right) y$ admits a solution if and only if there exists $x\in F$ that is not a root of the polynomial $X^2-1$ \textit{i.e.} if and only if $|F| \ge 4$.

        \item Let $S_n := \{(i,i+1) | 1\le i\le n-1\}$ and let us show that $\left( \mathfrak{S}_n,S_n \right)$ is irreducible by induction over $n$.
            The cases $n=0,1$ are trivial, so suppose $n\ge21$ and $\left( \mathfrak{S}_{n-1}, S_{n-1} \right)$ irreducible.

            Let $X$ be a subset of $S_n$ such that every element of $X$ commutes with every element of $S_n -X$. Set $X' := X \cap S_{n-1}$, it is a subset of $S_{n-1}$ that commutes with every element of its complement in $S_{n-1}$, thus by hypothesis it is either $S_{n-1}$ or $\emptyset$. If $X' = S_{n-1}$ then $\left( n-1,n \right)$ does not commute with $(n-2,n-1) \in X'$ so $\left( n-1n \right)\in X$ and $X = S_n$. Otherwise, if $X' = \emptyset$ then as $\left( n-2,n-1 \right)$ belongs to $S_n -X$ so does $\left( n-1,n \right)$ and hence $X=\emptyset$.
    \end{enumerate}

    Therefore, by theorem \ref{thm:simple} the group $G_1 / (Z \cap G_1) = SL_n(F) / \left( Z \cap SL_n\left( F \right) \right)$ is simple or trivial.
    Now let us verify that $Z$ is the center of $SL_n\left( F \right)$, by using corollary \ref{cor:2}. We see by conjugating by permutation matrices that very matrix in $Z$ is diagonal. The only strictly upper triangular matrix that is diagonal is the identity matrix. Hence, $Z \cap U = \{I_n\}$ and $Z$ is the center of $SL_n\left( F \right)$ . Therefore, $PSL_n\left( F \right)$ is simple because it is not trivial : for example the image of $\left( \begin{smallmatrix}
            0 & 1 \\ 1 & 0\\
    \end{smallmatrix}
     \right) \in SL_n\left( F \right)$ in $PSL_n(F)$ is nontrivial.
\end{proof} 

\begin{remark}
    This property has not been fully formalized yet. Especially, formalizing the fact that the hypothesis 2 holds will be challenging.
\end{remark}



Finally, we end this report by proving that the groups $SL_n(F)$ and $PSL_n(F)$ are groups with $BN\pi$-triplet.

\begin{proposition}
    $SL_n\left( F \right)$ and $PSL_n\left( F \right)$ are endowed with $BN\pi$-triplets. 
\end{proposition}
\begin{proof}
    First, the lemma \ref{lem:subBN} applied in the cases of $H = \{1\}$.tells us that $\left( B_n\left( F \right) \cap SL_n(F), \tilde{N}_n(F), \pi \right)$ is $BN\pi$-triplet over $SL_n(F)$.

    Then, one can verify that the center $Z$ of $SL_n\left( F \right)$ is the group of scalar matrices of determinant $1$, thus is a subgroup of $B_n(F) \cap SL_n\left( F \right)$. Therefore, we can endow $PSL_n(F)$ with the quotient $BN\pi$-triplet of $\left( B_n(F) \cap SL_n(F), N_n(F), \pi \right)$ by $Z$ (see \ref{def:quotBN} for the definition of quotient $BN\pi$-triplet).
\end{proof}

\begin{implementation} \
\begin{leancode}
def SpecialLinearGroup_BNpiTriplet : BNpiTriplet (Matrix.SpecialLinearGroup n F) (Equiv.Perm n) :=
  SubBNpiTriplet (GeneralLinearGroup_BNpiTriplet n F) ...

def ProjectiveSpecialLinearGroup_BNpiTriplet :
  BNpiTriplet (Matrix.ProjectiveSpecialLinearGroup n F) (Equiv.Perm n) :=
    QuotientBNpiTriplet SpecialLinearGroup_BNpiTriplet ...
\end{leancode}
\end{implementation}
